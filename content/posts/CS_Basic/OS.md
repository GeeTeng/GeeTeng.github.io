---
title: "操作系统"
date: 2025-01-10
tags: [CS Basic]
description: "操作系统知识笔记"
showDate: true
math: true
chordsheet: true
---



---

## 死锁

**定义**：在并发环境下，各进程因竟争自由而造成的一种互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。



### **死锁发生的4个必要条件：**

- **互斥**条件：必须互斥使用的资源的争抢才会导致死锁。
- **不剥夺**条件：进程所获得资源在使用完之前，*不能由其他进程强行夺走*，只能主动释放。
- **请求和保持**条件：已经保持了至少一个资源，但又提出了新的资源请求，而该资源被其他进程占有，请求进程被阻塞，但又对自己已有的资源保持不放。
- **循环等待**条件：存在一种进程资源的*循环等待链*，链中的每一个进程已获得的资源同时被下一个进程所请求。

---

### 怎么避免死锁？

1. **破坏死锁产生的4个必要条件。**

   破坏互斥条件：把互斥使用的资源改造为允许共享使用，采用**SPOOLing**技术。

   破坏不剥夺条件：1. 当请求的新资源得不到满足时，必须立即释放保持的所有资源，以后需要再重新申请。

   ​			       2. 将想要的资源强行剥夺，一般需要剥夺给优先级更高的进程使用。

   破坏请求和保持条件：采用**静态分配方法**，即在进程运行前一次性申请完它所需要的全部资源。

   破坏循环等待条件：采用**顺序资源分配法**，给系统中资源编号，规定每个进程必须按编号递增的顺序请求资源，小编号等待大编号。

2. **防止系统进入不安全状态（如：银行家算法）。**

   银行家算法（Dijkstra）**核心思想**：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态（可能会发生死锁），以此来决定是否答应新资源的分配请求。

   1. 检查此次申请是否超过了之前声明的最大需求数
   2. 检查此时系统剩余的可用资源是否还能满足这次请求
   3. 试探着分配 更改各数据结构
   4. 用安全性算法检查此次分配是否会导致系统进入不安全状态

   ![01](/images/CS_Basic/OS/01.png)

3. **允许死锁的发生，但操作系统需要负责检测死锁的发生，然后解除死锁。**

   两种节点：**进程结点**、**资源结点**

   两条边：进程结点一>资源结点、资源结点一>进程结点

   图中p1进程可以像R2拿走一个空闲资源，并完成该进程后归还R1的资源，使P2能够成功申请，于是所有边会消去，则称该图**可完全简化**。而不可完全简化的，会发生死锁。

   ![02](/images/CS_Basic/OS/02.png)

   解除死锁的方法：

   - **资源剥夺法**：挂起（暂时放在外存上）某些死锁进程，并抢占它的资源。但应该防止挂起进程饥饿。
   - **撤销进程法**：强制撤销死锁进程，剥夺这些进程的资源。缺点：代价大，功亏一篑。
   - **进程回退法**：设置还原点，让死锁进程回退。

