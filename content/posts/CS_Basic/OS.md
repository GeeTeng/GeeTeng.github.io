---
title: "操作系统"
date: 2025-01-10
tags: [CS Basic]
description: "操作系统知识笔记"
showDate: true
math: true
chordsheet: true
---

# 1. 第一章 操作系统概述

## 1.1 操作系统概念、特征

操作系统是指**控制和管理整个计算机系统的硬件和软件资源**，并**合理的组织调度计算机的工作和资源的分配**，以提供给用户和其他软件方便的接口和环境集合。

- **并发**

并发是指**两个或多个事件在同一时间间隔内发生**。操作系统的并发是通过分时得以实现的。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它具有处理和调度多个程序同时执行的能力。

- **共享**

资源共享就是共享，系统中的资源**可供内存中多个并发执行的进程同时使用**，可分为以下两种。

1. **互斥共享方式**

   比如打印机，不能同时打印两份内容，不然会造成内容混淆。

2. **同时访问方式**

   交替的对该资源进行访问 “分时共享”。

- **虚拟**

操作系统中利用了多种虚拟技术，分别用来实现**虚拟处理机**、**虚拟内存**和**虚拟外部设备**。

在虚拟处理器技术中，**让多道程序并发执行来分时使用一台处理器**，虽然只有一台处理器，但是能同时为多个用户服务。把一台物理上的CPU虚拟为多态逻辑上的CPU称为虚拟处理器。

虚拟存储器，从逻辑上来扩充存储器的容量。

虚拟设备技术，将一台物理IO设备虚拟为多台逻辑上的IO设备，允许多个用户同时访问的共享设备。

- **异步**

在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。



### 操作系统的目标和功能

为了给多道程序提供良好的运行环境，操作系统应该具有：**处理器管理**、**存储器管理**、**文件管理**和**设备管理**，还必须向用户提供接口，同时操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。

1. **处理器管理**

   对处理器的管理可归结为对进程的管理，主要功能有：进程控制、进程同步、进程通信、死锁处理、处理器调度等。

2. **存储器管理**

   方便用户使用以及提高内存的利用率，存储器管理应具备：内存分配、地址映射、内存保护、共享和内存扩充等。

3. **文件管理**

   包括文件的存储空间管理、目录管理和文件读写管理、文件保护。

4. **设备管理**

   完成用户的IO请求，主要包括混充管理、设备分配、设备处理和虚拟设备等。

为了方便用户使用操作系统，操作系统还提供了**用户接口**，分为以下两类。

1. **命令接口**

   使用命令接口进行作业控制的主要方式有两种：**联机命令接口**和**脱机命令接口**。

2. **程序接口**

   程序接口由一组**系统调用命令**组成，用户可以直接使用命令向系统提出各种请求。



### 操作系统的结构

简单结构、模块化结构、分层式结构、微内核结构。



## 1.3 操作系统的运行环境

操作系统在具体实现上划分了**用户态**、**核心态**。

操作系统内核包括以下4方面：

1. **时钟管理**

   操作系统需要通过时钟管理，向用户提供标准的系统时间。通过时钟中断的管理，可以实现进程切换。

2. **中断机制**

   引入中断机制是为了提高多道程序运行环境中CPU的利用率。

3. **原语**

   原语处于操作系统最底层，是最接近硬件的部分；具有原子性（一气呵成，不可中断）；运行时间短、调用频繁。

4. **系统控制的数据结构及处理**

   常见的基本操作有以下3种，进程管理、存储器管理、设备管理。

### 中断和异常

引入核心态和用户态之后，就需要考虑如何在这两种状态下切换。**中断是让操作系统内核夺回CPU使用权的唯一途径。**内核工作在核心态，应用程序工作在用户态，系统不允许用户使用核心态的功能，但是它们又必须使用。

- **中断（外中断）**

  中断信号来源于CPU外部，与当前执行的指令无关。比如说时钟中断和I/O中断请求，当输入输出任务完成时，向CPU发送中断信号，或时钟部件每隔50ms发送一个中断信号。

- **异常（内中断）**

  源于CPU执行指令内部，比如程序的非法操作。

一些由用户态转为核心态的例子：1）用户程序要求系统服务 2）发生一次中断 3）用户程序产生错误 4）用户程序企图执行特权指令 



---

# 2. 第二章 进程管理

## 2.1 进程与线程

进程控制块（PCB）描述进程的基本情况和运行状态，**PCB是进程存在的唯一标志**。

进程由**PCB**、**程序段**、**数据段**组成。

### 进程的特征

**动态性**(最基本的特性)、**并发性**、**独立性**、**异步性**、结构性。

独立性：能够独立运行、独立获得资源、独立接受调度的基本单位。

异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供**进程同步机制**来解决异步问题。

### 进程的组织

进程的组织方式分为**链接方式**、**索引方式**。

![04](/images/CS_Basic/OS/04.png)

![04](/images/CS_Basic/OS/05.png)

### 进程控制

进程控制相关原语：创建、终止、阻塞、唤醒、切换，用**原语实现进程控制**（一气呵成）。

**创建进程的过程**如下：

1. 申请一个空白的PCB
2. 分配资源和必要的空间
3. 初始化PCB
4. 将PCB插入就绪队列，等待被调度运行

**终止进程的过程**如下：

1. 从PCB集合中找到终止进程的PCB
2. 如果进程正在运行，剥夺CPU，将CPU分配给其他进程
3. 终止其所有子进程
4. 将该进程拥有的所有资源归还给父进程 / 操作系统
5. 删除PCB

**阻塞和唤醒进程的过程**如下：

![06](/images/CS_Basic/OS/06.png)

**切换进程的过程**如下：

1. 将运行环境信息存入PCB
2. 将PCB移入相应队列
3. 选择另一个进程执行，并更新其PCB
4. 根据PCB恢复新进程所需的运行环境

**无论哪个进程控制原语，要做的无非3件事情**：

1. 更新PCB中信息
2. 将PCB插入合适的队列
3. 分配/回收资源

### 进程的状态与转换

![03](/images/CS_Basic/OS/03.png)

注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理器，只要活得处理器资源就立即执行；而等待状态是指进程需要其他资源或等待某一事件，及时处理器空闲也不能运行。

### 进程的通信

通信方法分为**共享存储**、**消息传递**、**管道通信**。

1. **共享存储**

   ![07](/images/CS_Basic/OS/07.png)

2. **消息传递**

   分为**直接通信**（直接告诉操作系统进程B的地址，让其发送）和**间接通信**（发送到信箱中，等待进程B接受）方式。

3. **管道通信**

   像是循环队列一样，先进先出。

   ![08](/images/CS_Basic/OS/08.png)

### 线程概念和多线程模型

引入线程是为了减小程序在并发执行时所付出的时空开销，比如：QQ应用程序打视频的同时要打字、传文件。

**线程不拥有系统资源，同一进程的各线程间共享进程的资源，进程内的线程对其他进程不可见。**

**线程是独立调度的基本单位，进程是资源拥有的基本单位。**

![13](/images/CS_Basic/OS/13.png)

- **一对一模型**

  一个用户级线程映射到一个内核级线程，一个进程占用多个内核级线程。

  ![10](/images/CS_Basic/OS/10.png)

- **多对一模型**

  多个用户级线程映射到一个内核级线程

  ![11](/images/CS_Basic/OS/11.png)

- **多对多模型**

  n个用户级线程映射到m个内核级线程（n >= m）

  ![12](/images/CS_Basic/OS/12.png)

## 2.2 调度

一个作业从开始到完成，需要经历三级调度：**作业调度（高级调度）**、**内存调度（中级调度）**、**进程调度（低级调度）**

![09](/images/CS_Basic/OS/09.png)

什么时候会调度？

1. 当前运行进程**主动放弃**处理机（进程完成/发生异常。主动请求阻塞）
2. 当前运行进程**被动放弃**处理机（时间片用完/处理更紧急的事/更高优先级）

什么时候不能进行进程调度/切换？

1. 在处理中断的过程中
2. 进程在操作系统**内核程序临界区**中
3. 在原子操作过程中

### 进程调度的方式

1. 非剥夺调度方式（只允许进程主动放弃处理机）

   只有运行进程阻塞或退出才触发调度程序工作。

2. 剥夺调度方式（可以抢占处理机）

   每个时钟中断或k个时钟中断会触发调度程序工作。

### 调度算法评价指标

**CPU利用率** = 忙碌的时间 / 总时间

**系统吞吐量** = 总共完成多少道作业 / 总共花了多少时间

**周转时间** = 作业完成时间 - 作业提交时间 | 平均周转时间 = 各作业周转时间之和 / 作业数

带权周转时间 = 作业周转时间 / 作业实际运行时间 （ >= 1）平均带权周转时间 = 各作业带权周转时间 / 作业数

**等待时间** = 进程建立后等待被服务的时间之和

**响应时间** = 提交请求到首次响应所用的时间

### 先来先服务FCFS

类似排队，按照先后顺序进行服务。**不会导致饥饿**。**非抢占式**。

优点：公平

**缺点**：**对短作业不利**

### 短作业优先SJF

**非抢占式**，运行时间越短的越先被服务。

下图，p1先到达，其他作业还没有到达，所以先执行p1。7s执行结束后所有作业都已经到达，选择运行时间最短的执行。

![14](/images/CS_Basic/OS/14.png)

还有**抢占式的短作业优先算法SRTN**

下图，p1先到达先执行，在2s之后p2到达，而p2运行时间比p1短，所以抢占处理机运行p2。运行了2s之后p3到达，p3的运行时间小于p2，所以运行p3。1s之后p3完成，p4刚好到达，此时p2运行时间最短，依次处理。

![15](/images/CS_Basic/OS/15.png)

优点：最短平均等待时间（作业到达时间差不多的时候）

**缺点**：长作业不利，可能会导致饥饿（如果一直有短作业到来）

### 高响应比优先HRRN

在每次调度时计算各个作业的响应比，**选择响应比最高的作业**为其服务。**非抢占式**，不会导致饥饿。

p1进程先到达，运行p1直到完成。在7s时，p2到达时间2s已经等待了5s，p3等待3s，p4等待2s。响应比是（等待时间 + 运行时间）/ 运行时间。p3响应比最高，先运行p3，以此类推。

![16](/images/CS_Basic/OS/16.png)

优点：综合了FCFS和SJF的优点。

等待时间相同时，要求服务时间短的优先（SJF 的优点）
要求服务时间相同时，等待时间长的优先（FCFS 的优点）

> 以上3种调度算法适合于早期的批处理系统，对于用户来说无法区分任务的紧急程度。所以引出交互式系统调度算法。

### 时间片轮转调度算法（RR）

伴随着分时操作系统出现，按照各进程到达就绪队列的顺序，轮流让各进程执行一个**时间片**（如100ms），若进程没有在一个时间片内执行完，就会被剥夺处理机，将进程重新放到就绪队列的队尾重新排队。**抢占式算法，由时钟装置发出时钟中断来通知CPU时间片已到**。

> 如果时间片太大，使得每个进程都可以在一个时间片就能完成，就会退化成FCFS调度算法。
>
> 如果时间片太小，进程切换过于频繁，系统会花费大量时间切换进程，而实际执行的时间减少。

优点：公平、响应快

**缺点**：不区分紧急程度、切换进程会有开销

### 优先级调度算法

每个作业都有各自的优先级，调度时选择优先级最高的作业执行。**会发生饥饿**（不断有优先级更高的作业）。

下图是**非抢占式的优先级调度算法**，优先级相同时选择先到达的执行。

![17](/images/CS_Basic/OS/17.png)

也有**抢占式的优先级调度算法**，当新作业到达时，如果优先级高于当前进程，则可以抢占处理机。

就绪队列未必只有一个，也有**静态优先级**和**动态优先级**（优先级可在过程中变化）。

### 多级反馈队列调度算法

其他算法的折中权衡，**抢占式算法**，会导致饥饿。

1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。

2.新进程到达时先进入第一级队列，按照FCFS原则等待被分配时间片。**如果时间片用完，则进入下一级队列队尾**。如果此时已经再最下级的队列，则重新放回该队列队尾。

3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片。

下图中，p1先到达进入第1级队列中先执行，第1级队列时间片为1，之后p1时间片结束进入到第2级队列中，同时p2到达，运行p2后同样放入到第2级队列p1后面（队尾），执行时间片2s后p1还没执行完则放入第3级队列中，再执行第2级队列中的p2。在执行1s之后p3到达了，这个时候p3进入到第1级队列中，抢占了处理机。运行完p3后再运行，p2继续运行2个单位的时间片，最后执行p1。

![18](/images/CS_Basic/OS/18.png)

优点：公平、新到达的进程很快得到响应（RR），短进程较少时间可以完成（SPF），避免用户作假（缩短进程时间）、可灵活调整各类进程的偏好程度（CPU密集型进程、I/O密集型进程）

### 多级队列调度算法

![19](/images/CS_Basic/OS/19.png)

## 2.4 死锁

**定义**：在并发环境下，各进程因竟争自由而造成的一种互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。



### 死锁发生的4个必要条件：

- **互斥**条件：必须互斥使用的资源的争抢才会导致死锁。
- **不剥夺**条件：进程所获得资源在使用完之前，*不能由其他进程强行夺走*，只能主动释放。
- **请求和保持**条件：已经保持了至少一个资源，但又提出了新的资源请求，而该资源被其他进程占有，请求进程被阻塞，但又对自己已有的资源保持不放。
- **循环等待**条件：存在一种进程资源的*循环等待链*，链中的每一个进程已获得的资源同时被下一个进程所请求。

---

### 怎么避免死锁？

1. **破坏死锁产生的4个必要条件。**

   破坏互斥条件：把互斥使用的资源改造为允许共享使用，采用**SPOOLing**技术。

   破坏不剥夺条件：1. 当请求的新资源得不到满足时，必须立即释放保持的所有资源，以后需要再重新申请。

   ​			       2. 将想要的资源强行剥夺，一般需要剥夺给优先级更高的进程使用。

   破坏请求和保持条件：采用**静态分配方法**，即在进程运行前一次性申请完它所需要的全部资源。

   破坏循环等待条件：采用**顺序资源分配法**，给系统中资源编号，规定每个进程必须按编号递增的顺序请求资源，小编号等待大编号。

2. **防止系统进入不安全状态（如：银行家算法）。**

   银行家算法（Dijkstra）**核心思想**：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态（可能会发生死锁），以此来决定是否答应新资源的分配请求。

   1. 检查此次申请是否超过了之前声明的最大需求数
   2. 检查此时系统剩余的可用资源是否还能满足这次请求
   3. 试探着分配 更改各数据结构
   4. 用安全性算法检查此次分配是否会导致系统进入不安全状态

   ![01](/images/CS_Basic/OS/01.png)

3. **允许死锁的发生，但操作系统需要负责检测死锁的发生，然后解除死锁。**

   两种节点：**进程结点**、**资源结点**

   两条边：进程结点一>资源结点、资源结点一>进程结点

   图中p1进程可以像R2拿走一个空闲资源，并完成该进程后归还R1的资源，使P2能够成功申请，于是所有边会消去，则称该图**可完全简化**。而不可完全简化的，会发生死锁。

   ![02](/images/CS_Basic/OS/02.png)

   解除死锁的方法：

   - **资源剥夺法**：挂起（暂时放在外存上）某些死锁进程，并抢占它的资源。但应该防止挂起进程饥饿。
   - **撤销进程法**：强制撤销死锁进程，剥夺这些进程的资源。缺点：代价大，功亏一篑。
   - **进程回退法**：设置还原点，让死锁进程回退。

