---
title: "操作系统"
date: 2025-01-10
tags: [CS Basic]
description: "操作系统知识笔记"
showDate: true
math: true
chordsheet: true
---



---

---

# 1. 第一章 操作系统概述

## 1.1 操作系统概念、特征

操作系统是指**控制和管理整个计算机系统的硬件和软件资源**，并**合理的组织调度计算机的工作和资源的分配**，以提供给用户和其他软件方便的接口和环境集合。

### 并发

并发是指**两个或多个事件在同一时间间隔内发生**。操作系统的并发是通过分时得以实现的。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它具有处理和调度多个程序同时执行的能力。

### 共享

资源共享就是共享，系统中的资源**可供内存中多个并发执行的进程同时使用**，可分为以下两种。

1. **互斥共享方式**

   比如打印机，不能同时打印两份内容，不然会造成内容混淆。

2. **同时访问方式**

   交替的对该资源进行访问 “分时共享”。

### 虚拟

操作系统中利用了多种虚拟技术，分别用来实现**虚拟处理机**、**虚拟内存**和**虚拟外部设备**。

在虚拟处理器技术中，**让多道程序并发执行来分时使用一台处理器**，虽然只有一台处理器，但是能同时为多个用户服务。把一台物理上的CPU虚拟为多态逻辑上的CPU称为虚拟处理器。

虚拟存储器，从逻辑上来扩充存储器的容量。

虚拟设备技术，将一台物理IO设备虚拟为多台逻辑上的IO设备，允许多个用户同时访问的共享设备。

### 异步

在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。



### 操作系统的目标和功能

为了给多道程序提供良好的运行环境，操作系统应该具有：**处理器管理**、**存储器管理**、**文件管理**和**设备管理**，还必须向用户提供接口，同时操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。

1. **处理器管理**

   对处理器的管理可归结为对进程的管理，主要功能有：进程控制、进程同步、进程通信、死锁处理、处理器调度等。

2. **存储器管理**

   方便用户使用以及提高内存的利用率，存储器管理应具备：内存分配、地址映射、内存保护、共享和内存扩充等。

3. **文件管理**

   包括文件的存储空间管理、目录管理和文件读写管理、文件保护。

4. **设备管理**

   完成用户的IO请求，主要包括混充管理、设备分配、设备处理和虚拟设备等。

为了方便用户使用操作系统，操作系统还提供了**用户接口**，分为以下两类。

1. **命令接口**

   使用命令接口进行作业控制的主要方式有两种：**联机命令接口**和**脱机命令接口**。

2. **程序接口**

   程序接口由一组**系统调用命令**组成，用户可以直接使用命令向系统提出各种请求。



### 操作系统的结构

简单结构、模块化结构、分层式结构、微内核结构。



## 1.3 操作系统的运行环境

操作系统在具体实现上划分了**用户态**、**核心态**。

操作系统内核包括以下4方面：

1. **时钟管理**

   操作系统需要通过时钟管理，向用户提供标准的系统时间。通过时钟中断的管理，可以实现进程切换。

2. **中断机制**

   引入中断机制是为了提高多道程序运行环境中CPU的利用率。

3. **原语**

   原语处于操作系统最底层，是最接近硬件的部分；具有原子性（一气呵成，不可中断）；运行时间短、调用频繁。

4. **系统控制的数据结构及处理**

   常见的基本操作有以下3种，进程管理、存储器管理、设备管理。

### 中断和异常

引入核心态和用户态之后，就需要考虑如何在这两种状态下切换。**中断是让操作系统内核夺回CPU使用权的唯一途径。**内核工作在核心态，应用程序工作在用户态，系统不允许用户使用核心态的功能，但是它们又必须使用。

- **中断（外中断）**

  中断信号来源于CPU外部，与当前执行的指令无关。比如说时钟中断和I/O中断请求，当输入输出任务完成时，向CPU发送中断信号，或时钟部件每隔50ms发送一个中断信号。

- **异常（内中断）**

  源于CPU执行指令内部，比如程序的非法操作。

一些由用户态转为核心态的例子：1）用户程序要求系统服务 2）发生一次中断 3）用户程序产生错误 4）用户程序企图执行特权指令 



---

# 第二章 进程管理

## 进程与线程

进程控制块（PCB）描述进程的基本情况和运行状态，**PCB是进程存在的唯一标志**。

进程由**PCB**、**程序段**、**数据段**组成。

### 进程的特征

**动态性**(最基本的特性)、**并发性**、**独立性**、**异步性**、结构性。

独立性：能够独立运行、独立获得资源、独立接受调度的基本单位。

异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供**进程同步机制**来解决异步问题。

### 进程的组织

进程的组织方式分为**链接方式**、**索引方式**。

![04](/images/CS_Basic/OS/04.png)

![04](/images/CS_Basic/OS/05.png)

### 进程控制

进程控制相关原语：创建、终止、阻塞、唤醒、切换，用**原语实现进程控制**（一气呵成）。

**创建进程的过程**如下：

1. 申请一个空白的PCB
2. 分配资源和必要的空间
3. 初始化PCB
4. 将PCB插入就绪队列，等待被调度运行

**终止进程的过程**如下：

1. 从PCB集合中找到终止进程的PCB
2. 如果进程正在运行，剥夺CPU，将CPU分配给其他进程
3. 终止其所有子进程
4. 将该进程拥有的所有资源归还给父进程 / 操作系统
5. 删除PCB

**阻塞和唤醒进程的过程**如下：

![06](/images/CS_Basic/OS/06.png)

**切换进程的过程**如下：

1. 将运行环境信息存入PCB
2. 将PCB移入相应队列
3. 选择另一个进程执行，并更新其PCB
4. 根据PCB恢复新进程所需的运行环境

**无论哪个进程控制原语，要做的无非3件事情**：

1. 更新PCB中信息
2. 将PCB插入合适的队列
3. 分配/回收资源

### 进程的状态与转换

![03](/images/CS_Basic/OS/03.png)

注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理器，只要活得处理器资源就立即执行；而等待状态是指进程需要其他资源或等待某一事件，及时处理器空闲也不能运行。

### 进程的通信

通信方法分为**共享存储**、**消息传递**、**管道通信**。

1. **共享存储**

   ![07](/images/CS_Basic/OS/07.png)

2. **消息传递**

   分为**直接通信**（直接告诉操作系统进程B的地址，让其发送）和**间接通信**（发送到信箱中，等待进程B接受）方式。

3. **管道通信**

   像是循环队列一样，先进先出。

   ![08](/images/CS_Basic/OS/08.png)

## 死锁

**定义**：在并发环境下，各进程因竟争自由而造成的一种互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。



### **死锁发生的4个必要条件：**

- **互斥**条件：必须互斥使用的资源的争抢才会导致死锁。
- **不剥夺**条件：进程所获得资源在使用完之前，*不能由其他进程强行夺走*，只能主动释放。
- **请求和保持**条件：已经保持了至少一个资源，但又提出了新的资源请求，而该资源被其他进程占有，请求进程被阻塞，但又对自己已有的资源保持不放。
- **循环等待**条件：存在一种进程资源的*循环等待链*，链中的每一个进程已获得的资源同时被下一个进程所请求。

---

### 怎么避免死锁？

1. **破坏死锁产生的4个必要条件。**

   破坏互斥条件：把互斥使用的资源改造为允许共享使用，采用**SPOOLing**技术。

   破坏不剥夺条件：1. 当请求的新资源得不到满足时，必须立即释放保持的所有资源，以后需要再重新申请。

   ​			       2. 将想要的资源强行剥夺，一般需要剥夺给优先级更高的进程使用。

   破坏请求和保持条件：采用**静态分配方法**，即在进程运行前一次性申请完它所需要的全部资源。

   破坏循环等待条件：采用**顺序资源分配法**，给系统中资源编号，规定每个进程必须按编号递增的顺序请求资源，小编号等待大编号。

2. **防止系统进入不安全状态（如：银行家算法）。**

   银行家算法（Dijkstra）**核心思想**：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态（可能会发生死锁），以此来决定是否答应新资源的分配请求。

   1. 检查此次申请是否超过了之前声明的最大需求数
   2. 检查此时系统剩余的可用资源是否还能满足这次请求
   3. 试探着分配 更改各数据结构
   4. 用安全性算法检查此次分配是否会导致系统进入不安全状态

   ![01](/images/CS_Basic/OS/01.png)

3. **允许死锁的发生，但操作系统需要负责检测死锁的发生，然后解除死锁。**

   两种节点：**进程结点**、**资源结点**

   两条边：进程结点一>资源结点、资源结点一>进程结点

   图中p1进程可以像R2拿走一个空闲资源，并完成该进程后归还R1的资源，使P2能够成功申请，于是所有边会消去，则称该图**可完全简化**。而不可完全简化的，会发生死锁。

   ![02](/images/CS_Basic/OS/02.png)

   解除死锁的方法：

   - **资源剥夺法**：挂起（暂时放在外存上）某些死锁进程，并抢占它的资源。但应该防止挂起进程饥饿。
   - **撤销进程法**：强制撤销死锁进程，剥夺这些进程的资源。缺点：代价大，功亏一篑。
   - **进程回退法**：设置还原点，让死锁进程回退。

