---
title: "计算机网络"
date: 2025-01-13
tags: [CS Basic]
description: "计算机网络知识 胡科大教书匠笔记"
showDate: true
math: true
chordsheet: true
---

# 1. 第一章 概述

## 1.1 计算机网络体系结构

**七层OSI模型**

应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

应用层：各种应用软件，会发送一个探测数据包，探测双方网络是否能胡同。

表示层：用来描述文件的类型(比如发送图片，会在整体二进制数据前加上文件类型数据标记)、数据加密。

会话层：发起会话/接受会话

传输层：传输数据TCP、UDP

网络层：定义IP编址、路由功能，如数据转发

数据链路层：定义数据基本格式，如MAC地址

物理层：定义物理设备标准，如网线/光纤的接口类型、传输速率等

**五层模型**

应用层、传输层、网络层、数据链路层、物理层

**TCP/IP四层模型**

应用层（HTTP\SMTP\DNS\RTP）、运输层(TCP\UDP)、网络层(IP)、网络接口层

![03](/images/CS_Basic/ComputerNetwork/03.png)

**协议三要素：**

- **语法**：定义交换信息的格式
- **语义**：定义收发双方要完成的操作
- **同步**：定义收发双方的时序关系

## 1.2 计算机网络分类

![00](/images/CS_Basic/ComputerNetwork/00.png)

## 1.3 三种交换方式

- #### 电路交换

​	电话交换机接通电话线的方式称为电路交换，使用电路交换传送计算机数据时，其线路的传输效率往往很低。

​	**三个步骤**：

1. 建立连接
2. 通话
3. 释放连接

- #### 分组交换

​	分组交换采用的是**存储转发**技术

​	在发送报文之前，先把较长的报文划分成一个个**更小的等长**的数据段；然后在数据段的前面加上一些由必要的控制信息组成的**首部**	后，就构成了一个**分组**

​	**发送方**：构造分组、发送分组

​	**路由器**：缓存分组、转发分组

​	**接收方**：接受分组、还原报文

​	![01](/images/CS_Basic/ComputerNetwork/01.png)

- #### 报文交换


​	用于早期的电报通信网，现在较少使用，通常被分组交换方式所取代。

**对比**

![02](/images/CS_Basic/ComputerNetwork/02.png)

---

# 2. 第二章 物理层

## 2.1 物理层的基本概念

解决在各种传输媒体上传输比特0和1的问题，给数据链路层提供透明传输比特流的服务，如：双绞线、同轴电缆、光纤等。

物理层协议的主要任务

- **机械特性**：指明接口所用接线器的**形状**和**尺寸**、引脚数目和排列、固定和锁定装置。
- **电气特性**：指明在接口电缆的各条线上出现的**电压的范围**。
- **功能特性**：指明某条线上出现的某一电平的**电压表示何种意义**。
- **过程特性**：指明对于不同功能的各种可能**事件的出现顺序**。

## 2.2 传输媒体和传输方式

**导引型传输媒体**：同轴电缆、双绞线、光纤（多模光纤、单模光纤）、电力线

**非导引性传输媒体**：无线电波、微波、红外线、可见光

**串行传输 / 并行传输**

计算机远距离传输采用串行传输，计算机内部采用并行传输

**同步传输 / 异步传输**

内同步（曼彻斯特编码）

异步是指字节之间异步

**单项通信（单工）/ 双向交替通信（半双工）/双向同时通信（全双工）**

**单项通信**：**一种方向**，无线电广播就是这样的方式。

**双向交替通信**：**双方可以相互传输数据**，比如对讲机，但是不能同时传输。

**双向同时通信**：双方可以**同时发送、接收信息**，比如手机。

---

# 3. 第三章 数据链路层

## 3.1 数据链路层概述

**链路**就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。

**数据链路**是指把实现通信协议的硬件和软件加到链路上，就构成了链路。

数据链路层**以帧为单位传输和处理数据**

## 3.2 封装成帧

应用层传递应用层协议数据单元给运输层，运输层加上运输层协议首部传递给网络层，网络层将数据添加网络层协议首部传递给数据链路层，数据链路层添加**帧头**和**帧尾**。

![04](/images/CS_Basic/ComputerNetwork/04.png)

帧头和帧尾的作用之一就是**帧定界**。如下图，红色部分就是P2P帧定界标志。但是以太网MAC帧并没有帧定界标志。

> **那以太网的MAC帧怎么被提取一个个帧呢？**
>
> 实际上以太网V2的MAC帧交付给物理层后会添加前导码，前导码中前7个字节为**前同步码**，作用是使接收方的时针同步，之后的1字节为**帧开始定界符**。

![05](/images/CS_Basic/ComputerNetwork/05.png)

### **透明传输**

透明传输是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。**当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使接收方不会将这样的数据误认为是某种控制信息**。这样才能保证数据链路层的传输是透明的。

> **如何判断发送的数据中是帧定位符还是帧的数据？**
>
> 下图是P2P帧的格式，在数据部分每遇到5个1可以添加1个0，和帧的首尾区分开，在读取的时候再删除这个0。

![06](/images/CS_Basic/ComputerNetwork/06.png)



为了提高帧的传输效率，应当使帧的数据部分尽可能大一些。

## 3.3 差错检测

帧在传输过程中可能会出现误码，所以进行差错检测，在以太网V2的MAC帧中如上图，FCS就是检错码，通过检错算法就可以检查到是否出现了误码。

![07](/images/CS_Basic/ComputerNetwork/07.png)

### 奇偶校验

如果有奇数个位发生误码，则奇偶性发生变化，可以检查出误码；

如果有偶数个位发生误码，则奇偶性不发生变化，无法检查出误码；

### 循环冗余校验CRC

- 收发双方约定好一个生成多项式G(x)；
- 发送方基于发送的数据和生成多项式计算出差错检测码（冗余码），将其添加到待传输数据的后面一起传输；
- 接收方通过生成多项式来计算收到的数据是否产生了误码

如：
$$
G(x) = x^4 + x^2 + x + 1
$$
![08](/images/CS_Basic/ComputerNetwork/08.png)

## 3.4 可靠传输

尽管误码不能完全避免，但如果能实现**发送方发送什么，接收方就能收到什么**，就成为可靠传输。

不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做。



**TCP**向其上层提供面向连接的可靠传输服务

**UDP**向其上层提供无连接、不可靠传输服务

**IP**向其上层提供无连接、不可靠传输服务

**802.11无线局域网**要求数据链路层实现可靠传输

**以太网**不要求数据链路层实现可靠传输

### 停止-等待协议SW

如果接收方没有收到数据，发送方一直都收不到接收方传送回来的ACK，于是一直等待，所以要**设置超时重传**，**选择略大于”从发送方到接收方的平均往返时间“**，这样当超时的时候，发送方会重新传送数据。

![09](/images/CS_Basic/ComputerNetwork/09.png)

如果接收方发送的ACK丢失，发送方就不知道数据是否已经被接收，于是又发送一条DATA0数据给接收方，这时候接收方无法判断该数据是否接受过，所以要**将分组带上序号**，保证每次接收到的都是新的数据。

![10](/images/CS_Basic/ComputerNetwork/10.png)

但是接收方传送的ACK，发送方怎么判断是第几条信息的传送成功呢？当DATA0和DATA1同时发送时，如果都返回的是ACK，当有一条数据没有收到时，就无法判断出是哪条信息丢失了，所以要对ACK也编号。

但是**数据链路层中一般不会出现ACK分组迟到的情况，因此在数据链路层中可以不用给ACK分组编号**。

由于停止-等待协议的信道利用率太低了，于是出现了其他两种协议，即后退N帧协议GBN和选择重传协议SR。

### 回退N帧协议GBN（Go-Back-N）

如果Wt = 1，则跟停止等待协议相同了。发送窗口最大2^n -1，最小1。

对n号帧的确认采用**累计确认**方式，表明接收方已经收到n号帧和它之前的全部帧。

如果正确收到，则为n帧发出ACK；

否则全部丢弃，重传从最后一个确认开始。

![13](/images/CS_Basic/ComputerNetwork/13.png)

缺点：**必须按序接收帧，不按序会被丢弃**。为了提高性能，接收窗口的尺寸不应该再等于1（而应该大于1），以便接收方线收下失序到达但无误码的那些数据分组，等所缺分组收齐后再一并送交上层，于是引出选择重传协议。

### 选择重传协议SR

发送方一次可以发送N帧，可以不按序接收，重传没有确认的帧。

对每个正确收到的数据逐一确认，如果Wr = 1则与回退N帧协议相同了。



## 3.5 点对点协议PPP

帧格式

![14](/images/CS_Basic/ComputerNetwork/14.png)

透明传输

1. 面向比特的同步链路采用插入比特0的比特填充法
2. 面向字节的异步链路采用插入转义字符的字节填充法，如下：

![15](/images/CS_Basic/ComputerNetwork/15.png)

差错检测 使用循环冗余码检查FCS之前数据

![16](/images/CS_Basic/ComputerNetwork/16.png)

### 3.6 媒体接入控制MAC

共享信道要着重考虑的一个问题就是如何协调多个发送和接受站点对一个共享传输媒体的占用，即MAC。

![17](/images/CS_Basic/ComputerNetwork/17.png)

### 静态划分信道

1. **频分复用FDM**

   所有用户同时占用不同的频带资源并行通信。

   ![18](/images/CS_Basic/ComputerNetwork/18.png)

2. **时分复用TDM**

   时分复用技术将时间划分成一段段等长的时分复用帧，占用固定的时隙。

   ![19](/images/CS_Basic/ComputerNetwork/19.png)

3. **波分复用WDM**

   ![20](/images/CS_Basic/ComputerNetwork/20.png)

4. **码分复用CDM**

   该技术主要用于多址接入（多点接入：处理动态分配信道给用户），常被叫做码分多址CDMA。

   同理，频分复用FDM和时分复用TDM同样可用于多址接入，FDMA和TDMA。

   在CDMA中，每一个比特时间再划分为m个短的间隔，称为码片，通常m = 64 / 128。

   - 如果一个站要发送比特1，则发送它自己的m bit码片序列；

   - 如果一个站要发送比特0，则发送它自己的m bit码片序列的二进制反码。

   eg：码片序列为00011011，发送比特1：00011011，发送比特0：11100100。**按惯例将0写为-1，1写为+1**（直接序列扩频DSSS），所以该站点的码片序列为（-1，-1，-1，+1，+1，-1，+1，+1）

---

[网络通信协议(互联网协议) - cls超 - 博客园](https://www.cnblogs.com/clschao/articles/9578922.html#_label8)

## ip地址划分

> **A类**：1.0.0.1 ~ 126.255.255.254（0 - 127）
>
> **B类**：128.0.0.1 ~ 191.255.255.254（128 - 192）
>
> **C类**：192.0.0.1 ~ 223.255.255.254 （192 - 224）
>
> D类 组播 VRRP协议（224 - 239）
>
> E类 科研（240 - 255）
>
> 其中**127**地址可用作本地软件环回测试，进程之间通信。127.0.0.1（本机地址） 是一个**不可路由**的**私有 IP 地址**。
>
> 通过判断第1位地址为0还是1、第2位地址为0还是1..来判断是哪类地址。

私有ip地址范围：

A类 10.0.0.0 ~ 10.255.255.255

B类 172.16.0.0 ~ 172.31.255.255

C类 192.168.0.0 ~ 192.168.255.255

默认网关 = 路由器地址公网ip（自己电脑看是内网ip）



主机号全为0表示某个网络，主机号全为1表示某个网络下的所有主机，用于广播。

广播地址用于在同一个链路中互相连接的主机之间发送数据包。

## 子网掩码

子网掩码表示子网络特征的一个参数，它的网络部分全部为1，主机部分全部为0，比如255.255.255.128。

知道子网掩码就**可以判断两个IP地址是否处于同一网段**，将两个IP地址分别进行AND运算，比较结果是否相同，如果是的话就表明在同一网络中。

假设有一个IP地址172.16.10.1的子网掩码是255.255.255.0（对应二进制有24个1），所以可以写为172.16.10.1/24。

**IP协议的作用主要有两个，一个是为每一台计算机分配IP地址（DHCP动态分配），另一个是确定哪些地址在同一个子网络**。

## DNS解析

DNS（Domain Name System）：域名系统，**将域名解析成ip地址**。

计算机和计算机直接通信是通过ip:端口来实现的。

### DNS由来：

比如说你想访问百度，但是没办法记住它的ip地址，因为就算记住了百度，还有其他很多别的网站。于是计算机帮我们将ip地址保留在系统里，C:\windows\system32\drivers\etc\hosts文件

后来有网站专门提供最新的host，但是不断更新很麻烦，所以出现了DNS服务器。

比如阿里云的：235.5.5.5，谷歌 8.8.8.8。

### DNS解析流程

- **缓存查询**：首先浏览器会检查本地DNS缓存能不能查到，如果查不到就会检查操作系统缓存C盘host文件，如果还找不到就去本地DNS服务器发送请求。

- **根DNS服务器查询**：如果在本地DNS服务器缓存查不到，就会去根域名服务器请求解析（全球只有13台DNS根服务器，.com域名服务器.com .cn .cloud就是顶级域名，.代表根的意思）
- **顶级DNS服务器查询**：根DNS服务器返回给本地DNS域名服务器一个顶级DNS服务器地址。 
- **NameServer查询**：本地DNS服务器再向刚才获得的顶级DNS服务器发送解析请求。顶级DNS服务器会**返回此域名对应的Name Server域名服务器的地址**。 比如我要访问www.baidu.com，而这个域名是从baidu公司注册获得的，那么baidu公司上的服务器一定有相关信息。
- **域名和IP映射关系返回**：Name Server会查询并返回存储的域名和IP的映射关系表，连同TTL值。
- **本地DNS服务器缓存**：本地DNS服务器会根据TTL值（Time To Live 缓存有效时间）缓存这个映射关系。
- **将IP地址返回给本地电脑**：电脑根据TTL值缓存结果，完成域名解析。

**递归查询**：客户端发起请求后，**所有的查询工作由DNS服务器来完成**，直到找到最终的IP地址。

**迭代查询**：**客户端自己向每一层的DNS服务器发起查询请求**，从根DNS服务器开始，到顶级DNS服务器，再到目标域名的授权DNS服务器，直到获得结果。

---

linux上**查看DNS解析信息的指令**：dig、nslookup、host

```bash
www.  zhihu. com   .
三级域 二级域 顶级域 根域
```

### 域名解析记录

主要分为A记录、MX记录、CNAME记录、NS记录和TXT记录

[DNS域名详细解析过程(最全面，看这一篇就够)_dns解析-CSDN博客](https://blog.csdn.net/bangshao1989/article/details/121913780)



## 文字编码

ASCII码 **每个字符占1字节**，不支持中文。00000000 - 11111111涵盖256种符号。

GB2312 是由于ASCII不支持中文而诞生来的，**每个中文占2个字节**，但是只涵盖6700多个，其他字符占1个字节。

GBK 升级了GB2312，涵盖了2w多个中文。

Unicode 每个国家都有自己的语言，于是出现了万国码，**每个字符占4个字节**。

utf-8 由于Unicode的英文占据太多空间，所以推出可变长编码，**一个英文1个字节，1个汉字3个字节**。



## ARP协议

ARP协议的作用是**将ip地址解析成mac地址**，工作在网络层和数据链路层中间，在七层模型中属于**数据链路层**。

假设在局域网内，一台交换机连接多台设备，当192.168.19.11：57101想发送给192.168.19.16：80时，arp广播会请求寻找目标mac地址在哪。

主机会通过广播发送ARP请求，包含了目标主机的IP地址

当同一个链路中的所有设备收到了ARP请求后，就会拆开请求包，去核对IP地址和自己的IP地址是否一致，如果一致的话，就将自己的MAC地址塞入ARP响应包，返回主机。

`RARP协议`与ARP协议相反，已知MAC地址求IP地址。

![25](/images/CS_Basic/ComputerNetwork/25.png)



## NAT

由于IPv4的地址非常紧缺，所以提出一种网络地址转换NAT的方法，简而言之就是把私有IP地址转换成公有IP地址。

## TCP三次握手、四次挥手

**TCP三次握手：**

![21](/images/CS_Basic/ComputerNetwork/21.png)

- 源端口和目的端口，各占2个字节，分别写入源端口和目的端口；
- 序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；
- 确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；
- 数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；
- 保留，占6位，保留今后使用，但目前应都位0；
- 紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；
- 确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；
- 推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；
- 复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；
- 同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；
- 终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；
- 窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；
- 检验和，占2字节，校验首部和数据这两部分；
- 紧急指针，占2字节，指出本报文段中的紧急数据的字节数；
- 选项，长度可变，定义一些其他的可选的参数。

![22](/images/CS_Basic/ComputerNetwork/22.png)

- 第一次握手：客户端创建传输控制块TCB，进入监听Listen状态。设置`SYN = 1`，发送给服务器，设置序列号为`seq = x`，此时客户端处于同步已发送`SYN-SENT`状态。
- 第二次握手：设置`ACK = 1`表示确认应答，`ack = x + 1`表示已收到客户端x之前的数据，希望下次数据从x+1开始，设置`SYN = 1`，发送给客户端，设置序列号`seq = y`，此时服务器处于同步已接受SY`N-RCVD`状态。
- 第三次握手：设置`ACK = 1`表示确认应答，`ack = y + 1`，`seq = x + 1`表示接着上一个数据包seq = x继续发送。至此建立连接ESTABLISHED。

> #### 为什么TCP客户端最后还要发送一次确认呢？
>
> 防止已经失效的连接请求报文又突然传送到了服务器。
>
> 两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。



**TCP四次挥手：**

第一次挥手：客户端向服务端发送`FIN=1`，其序号为`seq=u`，它等于前面以传送过的数据的最后一个字节的序号加1。

第二次挥手：服务端收到释放连接请求，`ACK = 1`,`ack = u + 1`，`seq = v`，这个序号v是等于前面已传送过的数据的最后一个字节的序号加1，然后B就进入`CLOSE-WAIT(关闭等待)`状态。

第三次挥手：客户端收到来自服务端的确认后，就进入了`FIN-WAIT-2(终止等待2)`状态满等待B发出的连接释放报文段。若已经没有要发送的数据，其应用进程就通知TCP释放连接，这时服务端发出的连接释放报文段必须使`FIN = 1`，`seq = w`，还必须重复上次已发送过的确认号`ack = u + 1`。这时服务端就进入`LAST-ACK(最后确认)状态`，等待客户端的确认。

第四次挥手：客户端收到连接释放报文段后，必须确认，`ACK = 1`，`ack = w + 1`，`seq = u + 1`(因为FIN报文段要消耗1个序号)，然后客户端进入`TIME-WAIT(时间等待)`状态。

![23](/images/CS_Basic/ComputerNetwork/23.png)

现在TCP连接并没有释放掉，必须经过`2MSL`后，才可以进入到`CLOSED状态`。

> 为什么要等待2MSL？

如果客户端发送的 ACK 报文段丢失，服务器在接收不到 ACK 的情况下会一直重发 FIN 报文段，因此客户端为了确保服务器收到了 ACK，会设置一个定时器，并在 TIME-WAIT 状态等待 2MSL 的时间，如果在此期间又收到了来自服务器的 FIN 报文段，那么客户端会重新设置计时器并再次等待 2MSL 的时间，如果在这段时间内没有收到来自服务器的 FIN 报文，那就说明服务器已经成功收到了 ACK 报文，此时客户端就可以进入 CLOSED 状态了。

2MSL是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，这样新的连接中不会出现旧连接的请求报文

[图解 TCP 四次挥手｜深度解析｜为什么是四次｜为什么要等2MSL_tcp链接谁先发送-CSDN博客](https://blog.csdn.net/weixin_45304503/article/details/142427461)



> 为什么说TCP是面向字节流的协议而UDP是面向报文的协议？

UDP传输时，操作系统不会对消息进行拆分，也就是说**每个UDP报文就是一个用户消息的边界**。接收方读一个UDP报文就能读取到完整的用户消息。

那么如果收到了2个UDP报文，该怎么区分开？

操作系统在收到UDP报文后，会将其插入到队列里，队列的每一个元素就是一个UDP报文，当用户调用recvfrom()时就会从队列中取出一个数据。

而TCP传输时，消息会被分组成多个TCP报文。当发送数据时，数据并没有真正从网络上发送出去，只是从应用程序拷贝到了操作系统内核协议栈中。至于什么时候被发送，取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件。当两个消息的某个部分被分到同一个TCP报文时（比如说报文1Hello 报文2 World，变成了 报文1He 报文2lloWorld），就是粘包问题。



> 如何解决粘包？

1. 固定长度的消息

   规定一个消息长度是n字节，当接收方接受满n字节，就认为完整收到了。灵活性差。

2. 特殊字符作为边界

   在两个用户消息之间插入一个特殊的字符串，这样在接收数据时，如果读到这个特殊字符，就认为读完了一条完整的消息，**比如HTTP**。

3. 自定义消息结构

   首先用4个字节大小的变量来表示数据长度，数据紧跟其后。

   ```
   struct{
   	u_int32_t message_length;
   	char message_data[];
   }message;
   ```

   

## HTTP

超文本传输协议（HTTP）：一种无状态的，以请求应答方式运行，可扩展（添加自定义头）的协议。

**HTTP协议格式：**

![26](/images/CS_Basic/ComputerNetwork/26.png)

**请求行报文格式：**

![27](/images/CS_Basic/ComputerNetwork/27.png)

**响应行报文格式：**

![28](/images/CS_Basic/ComputerNetwork/28.png)

### HTTP请求的完整过程

1. **DNS解析：**当用户输入网址后，首先**DNS解析流程**。
2. **TCP三次握手：**解析完成后，TCP三次握手建立连接，客户端发送SYN包（同步请求），服务器返回SYN-ACK包（确认响应），客户端再返回ACK包（确认收到），连接建立成功。
3. **HTTP请求：**建立TCP连接后，浏览器会通过该连接发送HTTP请求报文，向服务器请求所需的资源（比如网页）；
4. **HTTP响应：**服务器收到请求后，返回HTTP响应报文，包括网页内容等；
5. **网页渲染：**浏览器收到HTTP响应后会根据响应内容进行页面渲染；
6. **TCP四次挥手：**一旦网页渲染完成，浏览器和服务器之间的连接通过TCP四次挥手断开。客户端发送FIN包（请求断开连接）。服务器返回ACK包（确认收到断开请求）。服务器发送FIN包（请求断开连接）。客户端返回ACK包（确认断开请求），连接完全关闭。



由于HTTP天生明文的特点，整个传输过程完全透明，任何人都能够截获、修改报文。所以诞生了HTTPS协议。

**对称加密**使用xor异或，将原文与密钥异或得到密文，将密文与密钥异或得到原文。

**非对称加密**：有公钥和私钥，公钥可以公开给任何人使用，而私钥必须保密。用公钥把数据加密传送给服务端，只能通过私钥解密。

- 使用公钥加密 使用私钥解密
- 使用私钥加密 使用公钥解密

TLS中使用混合加密方式，由于对称加密速度快而非对称加密速度慢。

**五大类HTTP状态码**：

|      | 具体含义                                         | 常见的状态码       |
| ---- | ------------------------------------------------ | ------------------ |
| 1xx  | 提示信息，表示协议处理的中间状态                 |                    |
| 2xx  | 服务器成功处理了客户端请求                       | 200、204、206      |
| 3xx  | 重定向，资源位置发生变动，需要客户端重新发送请求 | 301、302、304      |
| 4xx  | 客户端错误，请求报文有误，服务器无法处理         | 400、403、404      |
| 5xx  | 服务器错误，服务器在处理请求时内部发生了错误     | 500、501、502、503 |



**HTTP常见字段：**

`Host`服务器域名、`Content-Length`数据长度、`Connection`可以要求服务器使用HTTP长连接机制、`Content-Type`告诉客户端本次数据是什么格式、`Content-Encoding`说明数据的压缩方法。

HTTP协议**通过设置回车符、换行符作为HTTP header的边界，通过Content-Length字段作为HTTP body的边界**，这两个方式都是为了解决粘包的问题。

![24](/images/CS_Basic/ComputerNetwork/24.png)

HTTP长连接的特点是，**只要任意一端没有明确提出要断开连接，则保持TCP连接状态**。HTTP的Keep-Alive就是实现了这个功能，**可以使用同一个TCP连接来发送和接收多个HTTP请求 / 应答，避免了连接建立和释放的开销**。



