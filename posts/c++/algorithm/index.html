<!DOCTYPE html>
<html lang="en-us">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>

    <title>
    刷题笔记 | 
    
    GeeTeng</title>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="description" content="练习算法题时整理的思路
    ">


<meta property="og:url" content="http://localhost:1313/posts/c&#43;&#43;/algorithm/">
  <meta property="og:site_name" content="GeeTeng">
  <meta property="og:title" content="刷题笔记">
  <meta property="og:description" content="练习算法题时整理的思路">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:tag" content="C&#43;&#43;">


  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="刷题笔记">
  <meta name="twitter:description" content="练习算法题时整理的思路">


  <meta itemprop="name" content="刷题笔记">
  <meta itemprop="description" content="练习算法题时整理的思路">
  <meta itemprop="wordCount" content="2156">
  <meta itemprop="keywords" content="C&#43;&#43;">
<link rel="canonical" href="http://localhost:1313/posts/c&#43;&#43;/algorithm/" />

<link rel="icon" type="image/png" href="http://localhost:1313/image/favicon.ico">

<link rel="stylesheet" href="/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/bulma.min.css">

<link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.css" />
<script defer src="https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/contrib/auto-render.min.js" crossorigin="anonymous"
  onload="renderMathInElement(document.body, {
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false }
          ],
          throwOnError: false
        });"></script>



<link rel="stylesheet" href=/css/chordsheet.css>

<script src=/js/ramium.js></script>
<link rel="stylesheet" href=/css/ramium.css>



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
    integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
    integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
    integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>




</head>

<body>
    
     
    <style type="text/css">
        .fireworks {
            position: fixed;
            pointer-events: none;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
        }
        #particles-js {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;    
            height: 100vh;   
            z-index: -1;     
        }
    </style>
    <canvas class="fireworks"></canvas>
<script src="/js/anime.min.js"></script>
<script src="/js/fireworks.js"></script>


    <script type="text/javascript">
        fireworks.setCanvasSize();
    </script>
    <nav class="navbar is-dark" role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a class="navbar-item" href=/>
      
      <strong>GeeTeng </strong>
      
    </a>

    <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false"
      data-target="navbarBasicExample">
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
    </a>
  </div>

  <div id="navbarBasicExample" class="navbar-menu">
    <div class="navbar-start">
      
      
      <a class="navbar-item" href="/">Home</a>
      
      
      
      <div class="navbar-item has-dropdown is-hoverable">
        <a class="navbar-link">This Blog</a>
        <div class="navbar-dropdown">
          
          <a class="navbar-item" href="/tags/">All Tags</a>
          
          <a class="navbar-item" href="/posts/">All Posts</a>
          
        </div>
      </div>
      
      
      
      <a class="navbar-item" href="/about-me/">About Me</a>
      
      
    </div>

    <div class="navbar-end">
      

      
      <div class="navbar-item">
        <form id="cse-search-box-form-id" onsubmit="return executeQuery();" role="search">
          <div class="field has-addons">
            <div class="control is-expanded">
              <input id="cse-search-input-box-id" size=15 class="input" type="text" autocomplete="off"
                placeholder="&#xf1a0; Google search" style="font-family:Arial, FontAwesome">
            </div>

            <div class="control">
              <button type="submit" class="button is-black">
                <i class="fa fa-search"></i>
                </a>
              </button>
            </div>
          </div>
        </form>
      </div>
      
    </div>
  </div>
</nav><div class="columns is-centered">
        <div id="page-body" class="column is-7">

<div class="content-wrapper">
    
    
    <nav id="TableOfContents" class="table-of-contents">
        <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#剑指offer">剑指offer</a>
          <ul>
            <li><a href="#jz23-链表中环的入口结点">JZ23 链表中环的入口结点</a></li>
            <li><a href="#jz24-反转链表">JZ24 反转链表</a></li>
            <li><a href="#jz25-合并两个排序的链表">JZ25 合并两个排序的链表</a></li>
            <li><a href="#jz26-树的子结构">JZ26 树的子结构</a></li>
            <li><a href="#jz33-二叉搜索树的后序遍历序列">JZ33 二叉搜索树的后序遍历序列</a></li>
            <li><a href="#jz35-复杂链表的复制">JZ35 复杂链表的复制</a></li>
            <li><a href="#jz36-二叉搜索树与双向链表">JZ36 二叉搜索树与双向链表</a></li>
            <li><a href="#jz38-字符串的排列">JZ38 字符串的排列</a></li>
            <li><a href="#jz39-数组中出现次数超过一半的数字">JZ39 数组中出现次数超过一半的数字</a></li>
            <li><a href="#jz41-数据流中的中位数">JZ41 数据流中的中位数</a></li>
            <li><a href="#jz43-整数中1出现的次数">JZ43 整数中1出现的次数</a></li>
            <li><a href="#jz44-数字序列中某一位的数字">JZ44 数字序列中某一位的数字</a></li>
            <li><a href="#jz45-把数组排成最小的数">JZ45 把数组排成最小的数</a></li>
            <li><a href="#jz46-把数字翻译成字符串">JZ46 把数字翻译成字符串</a></li>
            <li><a href="#jz48-最长不含重复字符的字符串">JZ48 最长不含重复字符的字符串</a></li>
            <li><a href="#jz49-丑数">JZ49 丑数</a></li>
            <li><a href="#jz51-数组中的逆序对">JZ51 数组中的逆序对</a></li>
            <li><a href="#jz52-两个链表的第一个公共结点">JZ52 两个链表的第一个公共结点</a></li>
            <li><a href="#jz54-二叉搜索树的第k个结点">JZ54 二叉搜索树的第k个结点</a></li>
            <li><a href="#jz56-数组中只出现一次的两个数字">JZ56 数组中只出现一次的两个数字</a></li>
            <li><a href="#jz61-扑克牌顺子">JZ61 扑克牌顺子</a></li>
            <li><a href="#jz62-孩子们的游戏圆圈中最后剩下的数">JZ62 孩子们的游戏（圆圈中最后剩下的数）</a></li>
            <li><a href="#jz65-不用加减乘除做加法">JZ65 不用加减乘除做加法</a></li>
            <li><a href="#jz66-构建乘积数组">JZ66 构建乘积数组</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
    </nav>
    

    
    <div class="content blog">
        <h1>刷题笔记</h1>

        <div id="infobar" class="level is-mobile">
            <div class="level-left">
                
                <div class="level-item">
                    <p class="subtitle info date">Jan 1, 0001
                    </p>
                </div>
                

                <div class="level-item">
                    <p class="subtitle info">
                        30 mins read
                    </p>
                </div>
            </div>
            <div class="level-right is-hidden-touch">
                <div class="tags">
                    
                    <a class="tag is-dark is-rounded" href="/tags/c&#43;&#43;">C&#43;&#43;</a>
                    
                </div>
            </div>
        </div>

        <div class="tags is-hidden-desktop">
            
            <a class="tag is-dark is-rounded" href="/tags/c&#43;&#43;">C</a>
            
        </div>

        <div class="blog-text">
            

            <h2 id="剑指offer">剑指offer</h2>
<h3 id="jz23-链表中环的入口结点">JZ23 链表中环的入口结点</h3>
<p><strong>方法一：哈希集合</strong></p>
<p>环的入口结点就是第一个在哈希集合中已存在的结点。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>ListNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">EntryNodeOfLoop</span>(ListNode<span style="color:#f92672">*</span> pHead) {
</span></span><span style="display:flex;"><span>    unordered_set<span style="color:#f92672">&lt;</span>ListNode<span style="color:#f92672">*&gt;</span> st;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(pHead){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(st.count(pHead)) <span style="color:#66d9ef">return</span> pHead;
</span></span><span style="display:flex;"><span>        st.insert(pHead);
</span></span><span style="display:flex;"><span>        pHead <span style="color:#f92672">=</span> pHead<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> pHead;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>方法二：快慢指针</strong></p>
<ol>
<li>判断是否有环：快指针每次向后移动2位，慢指针每次向后移动1位，如果有环，两个指针必定会相遇；</li>
<li>如果有环，就将快指针从头重新开始，每次移动1位，慢指针也每次移动1位，最终相遇的点就是环的入口结点。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>ListNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">EntryNodeOfLoop</span>(ListNode<span style="color:#f92672">*</span> pHead) {
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> fast <span style="color:#f92672">=</span> pHead, <span style="color:#f92672">*</span>slow <span style="color:#f92672">=</span> pHead;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(fast <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(fast<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>        fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        slow <span style="color:#f92672">=</span> slow<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(fast <span style="color:#f92672">==</span> slow){
</span></span><span style="display:flex;"><span>            fast <span style="color:#f92672">=</span> pHead;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(fast <span style="color:#f92672">!=</span> slow){
</span></span><span style="display:flex;"><span>                fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>                slow <span style="color:#f92672">=</span> slow<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> fast;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="jz24-反转链表">JZ24 反转链表</h3>
<p><strong>迭代法:</strong></p>
<p>声明2个指针cur和pre，分别指向当前结点和前一个结点，同时用tmp来临时存储cur的后一个结点，以防cur在将next指针指向pre的时候断开链表。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>ListNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">ReverseList</span>(ListNode<span style="color:#f92672">*</span> head) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(head <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> pre <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(cur <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>){
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#f92672">*</span> tmp <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> pre; <span style="color:#75715e">// 指向前一个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pre <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>        cur <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> pre;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="jz25-合并两个排序的链表">JZ25 合并两个排序的链表</h3>
<p>新建一个头节点，如果p1值更小，则连p1；如果p2小则连p2，不断更新下一位置。</p>
<p>如果其中一个遍历完，另外一个链表还有剩余节点，则全部接到res之后。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>ListNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">Merge</span>(ListNode<span style="color:#f92672">*</span> p1, ListNode<span style="color:#f92672">*</span> p2) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p1 <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">return</span> p2; <span style="color:#75715e">// 一个空了返回另一个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(p2 <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">return</span> p1;
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> res <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ListNode(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> res;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p1 <span style="color:#f92672">&amp;&amp;</span> p2){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(p1<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&lt;</span> p2<span style="color:#f92672">-&gt;</span>val){
</span></span><span style="display:flex;"><span>            cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p1;
</span></span><span style="display:flex;"><span>            p1 <span style="color:#f92672">=</span> p1<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p2;
</span></span><span style="display:flex;"><span>            p2 <span style="color:#f92672">=</span> p2<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p1) cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="jz26-树的子结构">JZ26 树的子结构</h3>
<p>首先要判断pRoot1和pRoot2树是否为空，如果为空则返回false。在它俩都不为空的前提条件下去判断pRoot2是否为pRoot1的子树，首先去找pRoot1是否某个节点和pRoot2相等，如果存在的的话，就调用recursion函数，递归遍历判断是否完全匹配。</p>
<p>如果不完全匹配的话，就向下继续寻找，递归调用HasSubtree的左子树和右子树。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> HasSubtree(TreeNode<span style="color:#f92672">*</span> pRoot1, TreeNode<span style="color:#f92672">*</span> pRoot2) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">bool</span> result <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(pRoot1 <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> pRoot2 <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(pRoot1<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">==</span> pRoot2<span style="color:#f92672">-&gt;</span>val)
</span></span><span style="display:flex;"><span>				result <span style="color:#f92672">=</span> recursion(pRoot1, pRoot2);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果匹配失败就向下继续寻找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>result)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				result <span style="color:#f92672">=</span> HasSubtree(pRoot1<span style="color:#f92672">-&gt;</span>left, pRoot2) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>				HasSubtree(pRoot1<span style="color:#f92672">-&gt;</span>right, pRoot2);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 当匹配到pRoo1的某个结点值与pRoot2根结点相等时，进行递归 判断是否完全匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">recursion</span>(TreeNode<span style="color:#f92672">*</span> pRoot1, TreeNode<span style="color:#f92672">*</span> pRoot2){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(pRoot2 <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(pRoot1 <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(pRoot1<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">!=</span> pRoot2<span style="color:#f92672">-&gt;</span>val) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> recursion(pRoot1<span style="color:#f92672">-&gt;</span>left, pRoot2<span style="color:#f92672">-&gt;</span>left) <span style="color:#f92672">&amp;&amp;</span> recursion(pRoot1<span style="color:#f92672">-&gt;</span>right, pRoot2<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="jz33-二叉搜索树的后序遍历序列">JZ33 二叉搜索树的后序遍历序列</h3>
<p>写一个判断check函数，用来递归判断子树是否符合后序遍历序列，传递sequence的左右位置。</p>
<p>空树的时候返回false；</p>
<p>首先从后往前找右子树的结束位置（左右子树的分界线），然后再从前往后遍历判断左子树中是否有大于根节点的值，如果有说明不符合后序遍历；否则就继续递归它的左右子树。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> VerifySquenceOfBST(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> sequence) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(sequence.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">check</span>(sequence, <span style="color:#ae81ff">0</span>, sequence.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> sequence, <span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(l <span style="color:#f92672">&gt;=</span> r) <span style="color:#66d9ef">return</span> true; <span style="color:#75715e">// 如果只剩下1个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> root <span style="color:#f92672">=</span> sequence[r];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> r <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> sequence[j] <span style="color:#f92672">&gt;</span> root) j <span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> l; i <span style="color:#f92672">&lt;=</span> j; i <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(sequence[i] <span style="color:#f92672">&gt;</span> root) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> check(sequence, l, j) <span style="color:#f92672">&amp;&amp;</span> check(sequence, j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="jz35-复杂链表的复制">JZ35 复杂链表的复制</h3>
<p>将原链表的结点对应的拷贝结点连在其后，链表从A - B - C变成A - A&rsquo; - B - B&rsquo; - C - C&rsquo;。</p>
<p>然后再去连接random指针；</p>
<p>最后将原链表和复制的链表拆分，各自指向各自的下一节点。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    RandomListNode<span style="color:#f92672">*</span> Clone(RandomListNode<span style="color:#f92672">*</span> pHead) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>pHead) <span style="color:#66d9ef">return</span> pHead;
</span></span><span style="display:flex;"><span>        RandomListNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> pHead;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (cur) {
</span></span><span style="display:flex;"><span>            RandomListNode<span style="color:#f92672">*</span> tmp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> RandomListNode(cur<span style="color:#f92672">-&gt;</span>label);
</span></span><span style="display:flex;"><span>            tmp<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>            cur <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        RandomListNode <span style="color:#f92672">*</span>old <span style="color:#f92672">=</span> pHead, <span style="color:#f92672">*</span>clone <span style="color:#f92672">=</span> pHead<span style="color:#f92672">-&gt;</span>next, <span style="color:#f92672">*</span>res <span style="color:#f92672">=</span> pHead<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (old) {
</span></span><span style="display:flex;"><span>            clone<span style="color:#f92672">-&gt;</span>random <span style="color:#f92672">=</span> old<span style="color:#f92672">-&gt;</span>random <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">:</span> old<span style="color:#f92672">-&gt;</span>random<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(old<span style="color:#f92672">-&gt;</span>next) old <span style="color:#f92672">=</span> old<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(clone<span style="color:#f92672">-&gt;</span>next) clone <span style="color:#f92672">=</span> clone<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        old <span style="color:#f92672">=</span> pHead, clone <span style="color:#f92672">=</span> pHead<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(old){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(old<span style="color:#f92672">-&gt;</span>next) old<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> old<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(clone<span style="color:#f92672">-&gt;</span>next) clone<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> clone<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            old <span style="color:#f92672">=</span> old<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            clone <span style="color:#f92672">=</span> clone<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="jz36-二叉搜索树与双向链表">JZ36 二叉搜索树与双向链表</h3>
<p>举例子将二叉搜索树 1 - 2 - 3 变成双向链表，实际上是二叉树的中序遍历。</p>
<p>先找到最左的叶节点Convert(1)，然后递归调用返回</p>
<p>Convert(2)时pre = 1， pRootOfTree = 2；</p>
<p>Convert(3)时pre = 2，pRootOfTree = 2；最后回溯到Convert(2)。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	TreeNode<span style="color:#f92672">*</span> head <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>	TreeNode<span style="color:#f92672">*</span> pre <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">Convert</span>(TreeNode<span style="color:#f92672">*</span> pRootOfTree) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(pRootOfTree <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>		Convert(pRootOfTree<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (pre <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>			head <span style="color:#f92672">=</span> pRootOfTree;
</span></span><span style="display:flex;"><span>			pre <span style="color:#f92672">=</span> pRootOfTree;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			pre<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> pRootOfTree; <span style="color:#75715e">// 1-&gt;right = 2 | 2-&gt;right = 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			pRootOfTree<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> pre; <span style="color:#75715e">// 2-&gt;left = 1 | 3-&gt;left = 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			pre <span style="color:#f92672">=</span> pRootOfTree; <span style="color:#75715e">// pre = 2 | pre = 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>		Convert(pRootOfTree<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> head;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="jz38-字符串的排列">JZ38 字符串的排列</h3>
<p>dfs 回溯方法，在原字符串的基础上交换，然后再交换回来。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(string <span style="color:#f92672">&amp;</span>s, <span style="color:#66d9ef">int</span> index, vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>res) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(index <span style="color:#f92672">==</span> s.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            res.push_back(s);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> vis;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> index; i <span style="color:#f92672">&lt;</span> s.size(); i <span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>vis.count(s[i])){
</span></span><span style="display:flex;"><span>                vis.insert(s[i]);
</span></span><span style="display:flex;"><span>                swap(s[i], s[index]);
</span></span><span style="display:flex;"><span>                dfs(s, index <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, res);
</span></span><span style="display:flex;"><span>                swap(s[i], s[index]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> Permutation(string str) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> res;
</span></span><span style="display:flex;"><span>        dfs(str, <span style="color:#ae81ff">0</span>, res);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="jz39-数组中出现次数超过一半的数字">JZ39 数组中出现次数超过一半的数字</h3>
<p><strong>摩尔投票法步骤</strong></p>
<ol>
<li><strong>候选者 candidate</strong>：初始化为数组的第一个元素</li>
<li><strong>计数器 count</strong>：初始化为 1</li>
<li>遍历数组：
<ul>
<li><strong>当前元素等于 candidate</strong>：计数 <code>+1</code></li>
<li><strong>当前元素不等于 candidate</strong>：计数 <code>-1</code></li>
<li><strong>当计数变为 0</strong>：更换候选者，并将 <code>count</code> 设为 1</li>
</ul>
</li>
<li><strong>最终的 candidate 就是超过一半的元素</strong>（在题目保证存在的情况下）</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">MoreThanHalfNum_Solution</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> numbers) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> candidate <span style="color:#f92672">=</span> numbers[<span style="color:#ae81ff">0</span>], count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> numbers.size(); i <span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(numbers[i] <span style="color:#f92672">==</span> candidate) {
</span></span><span style="display:flex;"><span>                count <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                count <span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                    candidate <span style="color:#f92672">=</span> numbers[i];
</span></span><span style="display:flex;"><span>                    count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> candidate;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="jz41-数据流中的中位数">JZ41 数据流中的中位数</h3>
<p><strong>堆排序（双堆法）</strong></p>
<p>使用<strong>最大堆 + 最小堆</strong>的方式：</p>
<ul>
<li><strong>最大堆min</strong>（存储较小的一半数据，堆顶是最大值）</li>
<li><strong>最小堆max</strong>（存储较大的一半数据，堆顶是最小值）</li>
</ul>
<p>需要不断平衡两个堆的数量（min永远不会比max元素少），奇数个就在min堆里，偶数就通过求两个堆的堆顶元素就可以得到中位数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    priority_queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> min;
</span></span><span style="display:flex;"><span>    priority_queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>, greater<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> max; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Insert</span>(<span style="color:#66d9ef">int</span> num) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 先加入到min中，取出最大值加入max
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        min.push(num);
</span></span><span style="display:flex;"><span>        max.push(min.top());
</span></span><span style="display:flex;"><span>        min.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(min.size() <span style="color:#f92672">&lt;</span> max.size()) {
</span></span><span style="display:flex;"><span>            min.push(max.top());
</span></span><span style="display:flex;"><span>            max.pop();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">GetMedian</span>() { 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 奇数个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(min.size() <span style="color:#f92672">&gt;</span> max.size()) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">double</span>(min.top());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">double</span> (min.top() <span style="color:#f92672">+</span> max.top()) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="jz43-整数中1出现的次数">JZ43 整数中1出现的次数</h3>
<p>1.如何获取每一位数字的 左边数字 和 右边数字？</p>
<p>数字3101592，假如现在cur = 0，base = 10000（是当前考虑的位数）， high是cur左边的部分、cur是当前位的数字、low是cur右边的部分。</p>
<p>high = n / （base * 10） = n / 100000 = 31</p>
<p>​    cur = (n / base) % 10 = (n / 10000) % 10 = 0</p>
<p>​    low = n % base = n % 10000 = 1592</p>
<p>2.出现的次数取决于小于n的那些数，分情况讨论。</p>
<p>计算1出现的次数需要计算所有位上1出现的次数的加和，所以要遍历每一位，不断更新当前位前后的数字是什么。假设当前位是1时，计算1出现的次数。</p>
<ul>
<li>当cur = 0时</li>
</ul>
<p>还是拿31 0 1592举例子，如果当前位出现1了，那必然是high是0-30区间内，因为如果是311开头就比n要大了。当high是0-30的时候，无论low怎么选都比n小，所以low的选法可以有0-9999种，而low的选法正好=base10000。将high * base就是这种情况下1出现的次数。</p>
<ul>
<li>当cur = 1时</li>
</ul>
<p>cur = 1时 比如说310 1 592，需要分类讨论：</p>
<p>​        high从0 - 309时，low可以是0-999。所以是和cur = 0的情况一样的 =&gt; high * base</p>
<p>​        high是310时（1种选法），low只能是0 - 592（593种选法，是low + 1），low如果再大于592就比n要大了。 =&gt; 1 * （low + 1）</p>
<p>所以1的出现次数是（high * base） + （low + 1）</p>
<ul>
<li>当cur &gt; 1时</li>
</ul>
<p>cur大于1时，不需要再去考虑high和low怎么选不会比n大了。比如3101 5 92，high可以从 0 - 3101 而 low 可以从 0 - 99，所以直接就是 （high + 1） * base。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">NumberOf1Between1AndN_Solution</span>(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> base <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(base <span style="color:#f92672">&lt;=</span> n) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> high <span style="color:#f92672">=</span> n <span style="color:#f92672">/</span> (base <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> low <span style="color:#f92672">=</span> n <span style="color:#f92672">%</span> base;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> (n <span style="color:#f92672">/</span> base) <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(cur <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            cnt <span style="color:#f92672">+=</span> high <span style="color:#f92672">*</span> base;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(cur <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            cnt <span style="color:#f92672">+=</span> (high <span style="color:#f92672">*</span> base) <span style="color:#f92672">+</span>  (low <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            cnt <span style="color:#f92672">+=</span> (high <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> base;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        base <span style="color:#f92672">*=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> cnt;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="jz44-数字序列中某一位的数字">JZ44 数字序列中某一位的数字</h3>
<p><strong>位数减法</strong>：</p>
<p>​	1-9 有9个数字</p>
<p>​	10-99 有90个数字</p>
<p>​	100-999 有900个数字</p>
<p>**举例子：**n = 327，第一轮循环digit = 1， base是开始数字 = 1， sum = 9 * digit * base = 9， n -= 9 = 318；第二轮循环digit = 2，base = 10，sum = 180，n = 138；第三轮循环 n  &lt;  2700(sum在循环里的更新)，所以停止循环，但是我们确定了n是三位数。</p>
<p>然后确认是哪一个数字，且是该数字的哪一位。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">findNthDigit</span>(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> base <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> digit <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 数字的位数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>; <span style="color:#75715e">// 当前位数的总位数 9 180 2700
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(n <span style="color:#f92672">&gt;</span> sum) {
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">-=</span> sum;
</span></span><span style="display:flex;"><span>        digit <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        base <span style="color:#f92672">*=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span> <span style="color:#f92672">*</span> digit <span style="color:#f92672">*</span> base;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 找到是哪个数字 n这个时候是n减去从该位数开始的数字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span> (n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> digit;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 求数字的某一位是多少
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> (n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> digit;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> to_string(num)[index] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="jz45-把数组排成最小的数">JZ45 把数组排成最小的数</h3>
<p>重载比较排序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">cmp</span>(string <span style="color:#f92672">&amp;</span>x, string <span style="color:#f92672">&amp;</span>y) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> y <span style="color:#f92672">&lt;</span> y <span style="color:#f92672">+</span> x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>string <span style="color:#a6e22e">PrintMinNumber</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> numbers) {
</span></span><span style="display:flex;"><span>    string res <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(numbers.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> nums;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> numbers.size(); i <span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        nums.push_back(to_string(numbers[i]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    sort(nums.begin(), nums.end(), cmp);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i <span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">+=</span> nums[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="jz46-把数字翻译成字符串">JZ46 把数字翻译成字符串</h3>
<p><strong>动态规划</strong></p>
<p>首先排除一些特殊情况：</p>
<ol>
<li>当字符串是0时，没有对应编码</li>
<li>当字符串是10或20时，对应1种编码</li>
<li>当字符串当中某个数字是0，但是这个数字的前一位不是1或0。比如说是30 40等，则没有对应编码。</li>
</ol>
<p>其次对字符串进行动态规划</p>
<p>如果在11-19和21-26之间，则会有2种编码方式，dp[i] = dp[i - 1] + dp[i - 2]</p>
<p>如果是在1-10之间和20时，则只有1种编码方式，dp[i] = dp[i - 1]</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">solve</span>(string nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果是0就返回0种编码，是10 20则只有一种编码，如果是0且前面不是1或2则是不规则编码。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(nums <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;0&#34;</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(nums <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;10&#34;</span> <span style="color:#f92672">||</span> nums <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;20&#34;</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> nums.length(); i <span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(nums[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">&amp;&amp;</span> nums[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">&amp;&amp;</span> nums[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;2&#39;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 动态规划 初始dp为1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(nums.length() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> nums.length(); i <span style="color:#f92672">++</span>) {   
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 在11 - 19 和 21 - 26的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(nums[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">&amp;&amp;</span> nums[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">||</span> (nums[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;2&#39;</span> <span style="color:#f92672">&amp;&amp;</span> nums[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">&amp;&amp;</span> nums[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;7&#39;</span>)) {
</span></span><span style="display:flex;"><span>            dp[i] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1 - 10和20情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            dp[i] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> dp[nums.length()];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="jz48-最长不含重复字符的字符串">JZ48 最长不含重复字符的字符串</h3>
<p><strong>哈希 双指针</strong>：滑动窗口思想。</p>
<p>r在每次循环中向右移动遍历字符串，每次记录在哈希表里。当遇到重复字符时，l也开始向右移动，直到重复字符消失。这个时候取现有子串和之前字串长度的最大值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lengthOfLongestSubstring</span>(string s) {
</span></span><span style="display:flex;"><span>    unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mp;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, r <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; r <span style="color:#f92672">&lt;</span> s.length(); r <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        mp[s[r]] <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(mp[s[r]] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            mp[s[l]] <span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            l <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> max(r <span style="color:#f92672">-</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, res);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="jz49-丑数">JZ49 丑数</h3>
<p>把只包含质因子2、3和5的数称作丑数，有了定义我们就可以知道，<strong>丑数的形式就是2^x 3^y 5^z</strong>。</p>
<p>定义一个res数组存储丑数。已知第一个丑数是1，那么<strong>根据公式乘2、3、5，可以得到之后一系列丑数</strong>。</p>
<ol>
<li><strong>最小堆法</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetUglyNumber_Solution</span>(<span style="color:#66d9ef">int</span> index) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(index <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span><span style="color:#f92672">&gt;</span> mp;
</span></span><span style="display:flex;"><span>    priority_queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span><span style="color:#f92672">&gt;</span>, greater<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span><span style="color:#f92672">&gt;&gt;</span> pq;
</span></span><span style="display:flex;"><span>    mp.insert(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    pq.push(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> ugly <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> primes <span style="color:#f92672">=</span> {<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> index; i <span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        ugly <span style="color:#f92672">=</span> pq.top();
</span></span><span style="display:flex;"><span>        pq.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> prime : primes) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> newUgly <span style="color:#f92672">=</span> ugly <span style="color:#f92672">*</span> prime;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>mp.count(newUgly)) {
</span></span><span style="display:flex;"><span>                pq.push(newUgly);
</span></span><span style="display:flex;"><span>                mp.insert(newUgly);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ugly;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>2.动态规划</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetUglyNumber_Solution</span>(<span style="color:#66d9ef">int</span> index) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(index <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(index, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> p2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, p3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, p5 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> index; i <span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> nextUgly <span style="color:#f92672">=</span> min({dp[p2] <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>, dp[p3] <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>, dp[p5] <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span>});
</span></span><span style="display:flex;"><span>        dp[i] <span style="color:#f92672">=</span> nextUgly;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(nextUgly <span style="color:#f92672">==</span> dp[p2] <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>) p2 <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(nextUgly <span style="color:#f92672">==</span> dp[p3] <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>) p3 <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(nextUgly <span style="color:#f92672">==</span> dp[p5] <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span>) p5 <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> dp[index <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="jz51-数组中的逆序对">JZ51 数组中的逆序对</h3>
<p><strong>通过归并排序统计逆序对的方法</strong>：</p>
<p>左半部分 [l, mid] 已经是递增序列</p>
<p>右半部分 [mid+1, r]也是递增序列</p>
<p>但是当它们合并在一起时可能会形成逆序对，i在左半部分，j在右半部分。</p>
<p>nums[j] &lt; nums[i]时，nums[j]肯定大于nums[i]之前的所有数（否则早就加到tmp里了，也不会等到现在）。这个时候意味着，nums[i + 1], nums[i + 2], nums[i + 3]&hellip;&hellip;都大于nums[j] (因为左半部分递增，nums[i]你都不大于，剩下的咋可能大于)，但是同时nums[j]是比右半部分的nums[j - 1], nums[j - 2]&hellip;那些大（也因为右半部分递增）。所以逆序对的数量就是 i 到 mid 中间那些大于j的数，包括i和mid，所以是i - mid + 1。</p>
<p>动笔画一下就明白了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MOD <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e9</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">7</span>;
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> tmp;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">mergesort</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l <span style="color:#f92672">&gt;=</span> r) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> res <span style="color:#f92672">=</span> mergesort(nums, l, mid) <span style="color:#f92672">+</span> mergesort(nums, mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, i <span style="color:#f92672">=</span> l, j <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(i <span style="color:#f92672">&lt;=</span> mid <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;=</span> r) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(nums[i] <span style="color:#f92672">&lt;=</span> nums[j]) tmp[k <span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> nums[i <span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            tmp[k <span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> nums[j <span style="color:#f92672">++</span>]; 
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> (res <span style="color:#f92672">+</span> mid <span style="color:#f92672">-</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> MOD;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(i <span style="color:#f92672">&lt;=</span> mid) tmp[k <span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> nums[i <span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(j <span style="color:#f92672">&lt;=</span> r) tmp[k <span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> nums[j <span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> l, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> r; i <span style="color:#f92672">++</span>, j <span style="color:#f92672">++</span>) nums[i] <span style="color:#f92672">=</span> tmp[j];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">InversePairs</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>    tmp.resize(nums.size());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> mergesort(nums, <span style="color:#ae81ff">0</span>, nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="jz52-两个链表的第一个公共结点">JZ52 两个链表的第一个公共结点</h3>
<p>两个指针p1，p2分别在两条链表上同时走，如果它们到达尾部则指向另一条链表继续走，当双指针相遇时则是它们第一个公共节点。如果没有公共结点也会同时走到nullptr。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>ListNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">FindFirstCommonNode</span>( ListNode<span style="color:#f92672">*</span> pHead1, ListNode<span style="color:#f92672">*</span> pHead2) {
</span></span><span style="display:flex;"><span>    ListNode <span style="color:#f92672">*</span>p1 <span style="color:#f92672">=</span> pHead1, <span style="color:#f92672">*</span>p2 <span style="color:#f92672">=</span> pHead2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p1 <span style="color:#f92672">!=</span> p2) {
</span></span><span style="display:flex;"><span>        p1 <span style="color:#f92672">=</span> p1 <span style="color:#f92672">?</span> p1<span style="color:#f92672">-&gt;</span>next : pHead2;
</span></span><span style="display:flex;"><span>        p2 <span style="color:#f92672">=</span> p2 <span style="color:#f92672">?</span> p2<span style="color:#f92672">-&gt;</span>next : pHead1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p1;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="jz54-二叉搜索树的第k个结点">JZ54 二叉搜索树的第k个结点</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TreeNode</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> val;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TreeNode</span><span style="color:#f92672">*</span> left;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TreeNode</span><span style="color:#f92672">*</span> right;
</span></span><span style="display:flex;"><span>	TreeNode(<span style="color:#66d9ef">int</span> x) <span style="color:#f92672">:</span>val(x), left(<span style="color:#66d9ef">nullptr</span>), right(<span style="color:#66d9ef">nullptr</span>) {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TreeNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">insertBST</span>(TreeNode<span style="color:#f92672">*</span> root, <span style="color:#66d9ef">int</span> val) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>root) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> TreeNode(val);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (val <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">-&gt;</span>val) root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> insertBST(root<span style="color:#f92672">-&gt;</span>left, val);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> insertBST(root<span style="color:#f92672">-&gt;</span>right, val);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MidOrder</span>(TreeNode<span style="color:#f92672">*</span> root, <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> k, <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> res) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">||</span> k <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	MidOrder(root<span style="color:#f92672">-&gt;</span>left, k, res);
</span></span><span style="display:flex;"><span>	k<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (k <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		res <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>val;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	MidOrder(root<span style="color:#f92672">-&gt;</span>right, k, res);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>	TreeNode<span style="color:#f92672">*</span> root <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (cin <span style="color:#f92672">&gt;&gt;</span> n) {
</span></span><span style="display:flex;"><span>		root <span style="color:#f92672">=</span> insertBST(root, n);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (cin.get() <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\n&#39;</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> k;
</span></span><span style="display:flex;"><span>	cin <span style="color:#f92672">&gt;&gt;</span> k;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	MidOrder(root, k, res);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> res;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="jz56-数组中只出现一次的两个数字">JZ56 数组中只出现一次的两个数字</h3>
<p>异或运算，两个数一样异或结果为0，不一样则为1。</p>
<p>所以如果一个数组中有两个只出现一次的数字，那么这两个数一定二进制中有一位为1。比如说a的二进制有一位是1，b的二进制那一位是0，所以按这一位来分组。</p>
<p>首先把所有数异或，得到两个数不同的那几位的二进制，我们称为tmp。</p>
<p>然后遍历数组，和tmp相同的分为一组，和tmp不同的为一组。这样刚好就给两个只出现过一次的数字分开了，并且也把出现两次的数字也分到一组了（因为出现两次 =&gt; 二进制相同 =&gt; &amp;tmp一定相同）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1010</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[N], res[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">findNumAppearOnce</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> arr, <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> res1, <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> res2) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> arr[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		tmp <span style="color:#f92672">^=</span> arr[i];
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> ((tmp <span style="color:#f92672">&amp;</span> k) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) k <span style="color:#f92672">&lt;&lt;=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">&amp;</span> k) res1 <span style="color:#f92672">^=</span> arr[i];
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> res2 <span style="color:#f92672">^=</span> arr[i];
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	cin <span style="color:#f92672">&gt;&gt;</span> n;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		cin <span style="color:#f92672">&gt;&gt;</span> a[i];
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> res1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, res2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	findNumAppearOnce(a, res1, res2);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> res1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> res2;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="jz61-扑克牌顺子">JZ61 扑克牌顺子</h3>
<p>先排序从大到小，然后计算有多少个0可以转换。</p>
<p>计算一共需要多少距离，即相邻两个数字之间相差多少个0才可以补成顺子。最后进行判断。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">IsContinuous</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> numbers) {
</span></span><span style="display:flex;"><span>    sort(numbers.begin(), numbers.end());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> zeronum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(numbers[zeronum] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) zeronum <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> distance <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> zeronum; i <span style="color:#f92672">&lt;</span> numbers.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">++</span>) { <span style="color:#75715e">// 注意不要越界
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(numbers[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> numbers[i]) <span style="color:#66d9ef">return</span> false; <span style="color:#75715e">//如果遇到相等数字则不是顺子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        distance <span style="color:#f92672">+=</span> numbers[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> numbers[i] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(distance <span style="color:#f92672">&lt;=</span> zeronum) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="jz62-孩子们的游戏圆圈中最后剩下的数">JZ62 孩子们的游戏（圆圈中最后剩下的数）</h3>
<p><strong>递归</strong></p>
<p>n个数去掉第m位时，还剩下n - 1个数，但是m不变。所以从(n,m)的问题变成了(n−1,m)的子问题。</p>
<p>其中若是(n−1,m)的子问题返回的最后一个数是x，则(n,m)返回的结果就是(m+x)%n。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">LastRemaining_Solution</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> m) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> m <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> LastRemaining_Solution(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, m);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (m <span style="color:#f92672">+</span> x) <span style="color:#f92672">%</span> n;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="jz65-不用加减乘除做加法">JZ65 不用加减乘除做加法</h3>
<p><strong>位运算非递归</strong></p>
<p>先异或，再与并向右移位，再更新sum。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Add</span>(<span style="color:#66d9ef">int</span> num1, <span style="color:#66d9ef">int</span> num2) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> add <span style="color:#f92672">=</span> num2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> num1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(add <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> sum <span style="color:#f92672">^</span> add;
</span></span><span style="display:flex;"><span>        add <span style="color:#f92672">=</span> (add <span style="color:#f92672">&amp;</span> sum) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 更新sum为新的和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        sum <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> sum;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="jz66-构建乘积数组">JZ66 构建乘积数组</h3>
<p>B[i]该位置 = B左边 * B右边，右边需要从右向左累乘，左边需要从左向右累乘。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> multiply(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> A) {
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> B(A.size(), <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 从左到右累乘
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> A.size(); i <span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        B[i] <span style="color:#f92672">=</span> B[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> A[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 从右向左累乘
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> A.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>        B[i] <span style="color:#f92672">*=</span> tmp;
</span></span><span style="display:flex;"><span>        tmp <span style="color:#f92672">*=</span> A[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> B;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
        </div>
    </div>
</div><div id="social-media-share" class="has-text-centered">
	<p><i>Sharing is caring!</i></p>
	<br>
	
	<div class="share-buttons">
	    <a  href="https://www.facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b%2falgorithm%2f"
	        onclick="socialMediaPopUp(this.href, '', 500, 500); return false;"
	        title="Share on Facebook. Opens in a new window.">
	        <img src=/img/icons/45px/facebook.png>
	    </a>

	    <a  href="https://twitter.com/intent/tweet?text=%e5%88%b7%e9%a2%98%e7%ac%94%e8%ae%b0&url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b%2falgorithm%2f"
	        onclick="socialMediaPopUp(this.href, '', 500, 500); return false;"
	        title="Share on Twitter. Opens in a new window." >
	        <img src=/img/icons/45px/twitter.png>
	    </a>

		<a  href="http://www.reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b%2falgorithm%2f"
	        onclick="socialMediaPopUp(this.href, '', 900, 500); return false;"
	        title="Share on Reddit. Opens in a new window." >
	        <img src=/img/icons/45px/reddit.png>
	    </a>

	    <a  href="http://pinterest.com/pin/create/button/?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b%2falgorithm%2f"
	        onclick="socialMediaPopUp(this.href, '', 900, 500); return false;"
	        title="Share on Pinterest. Opens in a new window." >
	        <img src=/img/icons/45px/pinterest.png>
	    </a>

	    <a  href="http://www.tumblr.com/share/link?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b%2falgorithm%2f"
	        onclick="socialMediaPopUp(this.href, '', 900, 500); return false;"
	        title="Share on Tumblr. Opens in a new window." >
	        <img src=/img/icons/45px/tumblr.png>
	    </a>

		<a  href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b%2falgorithm%2f
			&title=%e5%88%b7%e9%a2%98%e7%ac%94%e8%ae%b0&summary=%e5%89%91%e6%8c%87offer%20JZ23%20%e9%93%be%e8%a1%a8%e4%b8%ad%e7%8e%af%e7%9a%84%e5%85%a5%e5%8f%a3%e7%bb%93%e7%82%b9%20%e6%96%b9%e6%b3%95%e4%b8%80%ef%bc%9a%e5%93%88%e5%b8%8c%e9%9b%86%e5%90%88%0a%e7%8e%af%e7%9a%84%e5%85%a5%e5%8f%a3%e7%bb%93%e7%82%b9%e5%b0%b1%e6%98%af%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%9c%a8%e5%93%88%e5%b8%8c%e9%9b%86%e5%90%88%e4%b8%ad%e5%b7%b2%e5%ad%98%e5%9c%a8%e7%9a%84%e7%bb%93%e7%82%b9%e3%80%82%0aListNode%2a%20EntryNodeOfLoop%28ListNode%2a%20pHead%29%20%7b%20unordered_set%26lt%3bListNode%2a%26gt%3b%20st%3b%20while%28pHead%29%7b%20if%28st.count%28pHead%29%29%20return%20pHead%3b%20st.insert%28pHead%29%3b%20pHead%20%3d%20pHead-%26gt%3bnext%3b%20%7d%20return%20pHead%3b%20%7d%20%e6%96%b9%e6%b3%95%e4%ba%8c%ef%bc%9a%e5%bf%ab%e6%85%a2%e6%8c%87%e9%92%88%0a%e5%88%a4%e6%96%ad%e6%98%af%e5%90%a6%e6%9c%89%e7%8e%af%ef%bc%9a%e5%bf%ab%e6%8c%87%e9%92%88%e6%af%8f%e6%ac%a1%e5%90%91%e5%90%8e%e7%a7%bb%e5%8a%a82%e4%bd%8d%ef%bc%8c%e6%85%a2%e6%8c%87%e9%92%88%e6%af%8f%e6%ac%a1%e5%90%91%e5%90%8e%e7%a7%bb%e5%8a%a81%e4%bd%8d%ef%bc%8c%e5%a6%82%e6%9e%9c%e6%9c%89%e7%8e%af%ef%bc%8c%e4%b8%a4%e4%b8%aa%e6%8c%87%e9%92%88%e5%bf%85%e5%ae%9a%e4%bc%9a%e7%9b%b8%e9%81%87%ef%bc%9b%20%e5%a6%82%e6%9e%9c%e6%9c%89%e7%8e%af%ef%bc%8c%e5%b0%b1%e5%b0%86%e5%bf%ab%e6%8c%87%e9%92%88%e4%bb%8e%e5%a4%b4%e9%87%8d%e6%96%b0%e5%bc%80%e5%a7%8b%ef%bc%8c%e6%af%8f%e6%ac%a1%e7%a7%bb%e5%8a%a81%e4%bd%8d%ef%bc%8c%e6%85%a2%e6%8c%87%e9%92%88%e4%b9%9f%e6%af%8f%e6%ac%a1%e7%a7%bb%e5%8a%a81%e4%bd%8d%ef%bc%8c%e6%9c%80%e7%bb%88%e7%9b%b8%e9%81%87%e7%9a%84%e7%82%b9%e5%b0%b1%e6%98%af%e7%8e%af%e7%9a%84%e5%85%a5%e5%8f%a3%e7%bb%93%e7%82%b9%e3%80%82%20ListNode%2a%20EntryNodeOfLoop%28ListNode%2a%20pHead%29%20%7b%20ListNode%2a%20fast%20%3d%20pHead%2c%20%2aslow%20%3d%20pHead%3b%20while%28fast%20%21%3d%20nullptr%29%7b%20if%28fast-%26gt%3bnext%20%3d%3d%20nullptr%29%20return%20nullptr%3b%20fast%20%3d%20fast-%26gt%3bnext-%26gt%3bnext%3b%20slow%20%3d%20slow-%26gt%3bnext%3b%20if%28fast%20%3d%3d%20slow%29%7b%20fast%20%3d%20pHead%3b%20while%28fast%20%21%3d%20slow%29%7b%20fast%20%3d%20fast-%26gt%3bnext%3b%20slow%20%3d%20slow-%26gt%3bnext%3b%20%7d%20return%20fast%3b%20%7d%20%7d%20return%20nullptr%3b%20%7d%20JZ24%20%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8%20%e8%bf%ad%e4%bb%a3%e6%b3%95%3a&source=rafed123.github.io"
	        onclick="socialMediaPopUp(this.href, '', 900, 500); return false;"
	        title="Share on LinkedIn. Opens in a new window." >
	        <img src=/img/icons/45px/linkedin.png>
	    </a>

	    <a  href="mailto:?subject=%e5%88%b7%e9%a2%98%e7%ac%94%e8%ae%b0&amp;body=Check out this site http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b%2falgorithm%2f"
	        title="Share via Email. Opens in a new window." >
	        <img src=/img/icons/45px/mail.png>
	    </a>
	</div>
</div>


<br>
<div id="disqus_thread"></div>
<script type="text/javascript">
    (function () {
        
        
        if (window.location.hostname == "localhost")
            return;

        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = 'disqus-code';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


        </div>
    </div>
<script async src="https://cse.google.com/cse.js?cx=google-search-code"></script>
<gcse:searchresults-only></gcse:searchresults-only>


<footer class="footer has-background-dark">
    <div class="content has-text-centered has-text-white">
        <p>
            © 2024 GeeTeng.My
            <a class="has-text-light" href="https://github.com/GeeTeng" target="_blank">
            GitHub</a>. 

	    Email: 15143483@qq.com
        </p>
    </div>
</footer>

<div id="particles-js"></div>
    <script src="/js/particles.min.js"></script>
    <script>
        particlesJS.load('particles-js', '/js/particlesjs-config.json', function() {
            console.log('callback - particles.js config loaded');
        });
    </script>
</body>

</html>
