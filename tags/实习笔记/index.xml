<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>实习笔记 on GeeTeng</title>
    <link>https://geeteng.github.io/tags/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 实习笔记 on GeeTeng</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 11 Jul 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://geeteng.github.io/tags/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>无人机AI玩法制作</title>
      <link>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%97%A0%E4%BA%BA%E6%9C%BAai%E7%8E%A9%E6%B3%95/</link>
      <pubDate>Fri, 11 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%97%A0%E4%BA%BA%E6%9C%BAai%E7%8E%A9%E6%B3%95/</guid>
      <description>无人机巡逻追踪玩家第一版： 目标：场景中有无人机巡逻飞行，无人机下挂着探照灯，巡逻时是白色灯光沿着样条线飞行；当遇到玩家后灯光变黄色并且追踪玩家，玩家在灯光区域内待到一定时间就会触发警报。&#xA;方法：&#xA;球形碰撞体为根组件位置在无人机的下方用于检测玩家是否进入这个区域（overlap）&#xA;骨骼网格体是无人机的骨骼 不做任何事&#xA;SpotLight灯光 更换灯光颜色&#xA;静态网格体是圆锥体形状的灯柱 更换材质上的颜色&#xA;SplineComponent 样条线组件 设置为绝对世界坐标&#xA;FloatingPawn移动组件用于飞行移动 更改速度&#xA;样条线组件有自己的方法可以得到当前点的位置，当移动到起始位置和终点位置时切换方向，假如有3个点，呢就是0 1 2 1 0这样遍历每个点的位置，无人机AIController直接MoveToLocation到这个点。&#xA;void APMS_PatrolDrone::MoveAlongPatrol() { if(PatrolRouteComponent) { FVector TargetPosition = GetSplinePointWorldPosition(); if(AIController) { AIController-&amp;gt;MoveToLocation(TargetPosition, 5); IncrementPatrolRoute(); } } } void APMS_PatrolDrone::IncrementPatrolRoute() { PatrolIndex += Direction; if(PatrolRouteComponent-&amp;gt;GetNumberOfSplinePoints() - 1 == PatrolIndex) { Direction = -1; } else if(PatrolIndex == 0) { Direction = 1; } } FVector APMS_PatrolDrone::GetSplinePointWorldPosition() { FVector Position = PatrolRouteComponent-&amp;gt;GetLocationAtSplinePoint(PatrolIndex, ESplineCoordinateSpace::World); return Position; } 在服务器端BeginPlay执行巡逻并且绑定球形碰撞体的Overlap委托。服务器用于改变速度，客户端更改灯光灯柱颜色。枚举变量FlightState有巡逻、追踪、警告状态，同步状态变量，在更改时调用OnSetState，</description>
    </item>
    <item>
      <title>UI制作体力条、选择房间</title>
      <link>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/ui%E5%88%B6%E4%BD%9C/</link>
      <pubDate>Fri, 04 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/ui%E5%88%B6%E4%BD%9C/</guid>
      <description>选择房间进入不同服务器 创建一个通用的UMG_CheckBox，其中包含显示房间号的TextBlock和CheckBox。&#xA;在UIDefine.ts中声明一个Map用来存储房间号和端口的映射关系 这个文件的数据全局都可以访问到。&#xA;export const RoomToPortMap: Map&amp;lt;string, string&amp;gt; = new Map&amp;lt;string, string&amp;gt;([ [&amp;#34;房间1&amp;#34;, &amp;#34;7770&amp;#34;], [&amp;#34;房间2&amp;#34;, &amp;#34;7771&amp;#34;], [&amp;#34;房间3&amp;#34;, &amp;#34;7772&amp;#34;], ]); 在LobbyMainSystem.ts（进入游戏前的大厅）的OnCreated中调用创建选择房间的CheckBox控件&#xA;声明一个Map用来存储CheckBox和房间号的映射，可以通过CheckBox对应的房间号查找到RoomToPortMap的房间对应的端口号。&#xA;CheckBoxToRoom: Map&amp;lt;UE.CheckBox, string&amp;gt; = new Map(); OnCreated(InUEWidget: UE.BJ_UserWidgetBase): void { super.OnCreated(InUEWidget); // ... const Container = this.UEWidget.CheckBoxContainer as UE.VerticalBox; this.CreateRoomCheckBox(Container); } protected UncheckOtherCheckBoxes(SelectCheckBox: UE.CheckBox): void { for (let [CheckBox] of this.CheckBoxToRoom) { if (CheckBox !== SelectCheckBox) { CheckBox.SetIsChecked(false); } } } protected GetSelectedRoomPort(): string | null { for (let [Checkbox, Room] of this.</description>
    </item>
    <item>
      <title>GAS知识点笔记</title>
      <link>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/gas%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Fri, 27 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/gas%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>GAS部分知识点 ASC（Ability System Component）主要组件（谁放技能）&#xA;AS（Attribute Set）角色身上可以用float表示的属性，如生命值、体力值等（技能改变的属性）&#xA;GA（Gameplay Abilities）角色的技能，包括攻击、疾跑、施法、翻滚、使用道具等，但不包括基础移动和UI（技能逻辑）&#xA;GE（Gameplay Effects）用于修改属性，如增加移动速度等（技能的效果）&#xA;GC（Gameplay Cues）播放特效、音效等（技能的视效）&#xA;GameplayTag（技能涉及的条件）&#xA;GameplayTask（技能长时行动）&#xA;GameplayEvent（技能消息事件）&#xA;ASC 在构造函数中创建ASC组件，其中ReplicationMode三种模式：Full、Mixed、Minimal&#xA;比如大招GE会被同步给队友，但是普通技能的冷却时间不会被同步。但是AI设置为Minimal，因为不需要别人知道他的技能冷却时间等。&#xA;其中Mixed模式必须要设置拥有者为控制器&#xA;PMSAbilitySystemComponent = CreateDefaultSubobject&amp;lt;UPMS_AbilitySystemComponent&amp;gt;(CharacterASCName); PMSAbilitySystemComponent-&amp;gt;SetReplicationMode(EGameplayEffectReplicationMode::Mixed); PMSAttributeSetBase = CreateDefaultSubobject&amp;lt;UPMS_AttributeSetBase&amp;gt;(CharacterAttributeSetName); Attribute 有两个值，BaseValue和CurrentValue，其中CurrentValue是BaseValue加上GE给的临时修改值后得到的，比如BaseValue生命值100，捡到药水瓶CurrentValue = 150&#xA;在PreAttributeChange中处理对CurrentValue的修改以及取值范围问题, 在PostGameplayEffectExecute中处理GE对BaseValue的修改&#xA;Meta Attribute是临时的、可被任意GE修改、不可同步的，将于任意Attribute交互的临时属性。 比如伤害值作为Meta Attribute占位符, 而不是使用GE直接修改生命值Attribute, 使用这种方法, 伤害值就可以在GameplayEffectExecutionCalculation中由buff和debuff修改, 并且可以在AttributeSet中进一步操作。&#xA;Set和Init的区别是在于Set只能设置basevalue， 而init可以设置currentvalue和basevalue&#xA;在PlayerCharacterBase的BeginPlay中，绑定委托、初始化属性、初始化GA&#xA;void APMS_CharacterBase::BeginPlay() { Super::BeginPlay(); BindAttributesDelegate(); PMSAttributeSetBase-&amp;gt;InitAttributes(); FTimerHandle hld; GetWorld()-&amp;gt;GetTimerManager().SetTimer(hld, this, &amp;amp;APMS_CharacterBase::InitAttributes, 0.1f); } void APMS_CharacterBase::BindAttributesDelegate() { if (IsValid(PMSAbilitySystemComponent) &amp;amp;&amp;amp; IsValid(PMSAttributeSetBase)) { HealthChangedDelegateHandle = PMSAbilitySystemComponent-&amp;gt;GetGameplayAttributeValueChangeDelegate(PMSAttributeSetBase-&amp;gt;GetHealthAttribute()).AddUObject(this, &amp;amp;ThisClass::HealthChanged); // ... } } void UPMS_AttributeSetBase::InitAttributes() { InitHealth(100.</description>
    </item>
    <item>
      <title>场景基础功能优化</title>
      <link>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9C%BA%E6%99%AF%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Wed, 18 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9C%BA%E6%99%AF%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>场景飞屑特效表现功能 当角色进入到一个触发范围内会在角色位置上生成特效&#xA;使用两个定时器分别是FPlayVfxTimerHandle和FCheckTimerHandle&#xA;删除Tick函数设置bCanEverTick = false 因为不使用到Tick所以删除会提升性能&#xA;构造函数中初始化初始化一个可见的无碰撞球体，为了布置场景时看到范围。在BeginPlay中直接获取球体半径作为DistanceToPlayer的值。&#xA;FCheckTimerHandle定时器用于每秒判断角色是否进入到范围内&#xA;FPlayVfxTimerHandle定时器用于不断播放特效，并设置一个bIsVFXPlaying用于判断是否正在播放特效，如果已经在播放特效了并且超出距离就会清空FPlayVfxTimerHandle特效播放定时器；如果没有在播放特效并且在距离范围内则会开启定时器。&#xA;为什么一定需要bIsVFXPlaying，因为否则人物在距离内时第一个FCheckTimerHandle会不断地调用CheckDistance函数导致无法播放特效。&#xA;APMS_VFXTriggerActor::APMS_VFXTriggerActor() { // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don&amp;#39;t need it. PrimaryActorTick.bCanEverTick = false; DetectionSphere = CreateDefaultSubobject&amp;lt;USphereComponent&amp;gt;(TEXT(&amp;#34;DetectionSphere&amp;#34;)); RootComponent = DetectionSphere; DetectionSphere-&amp;gt;SetCollisionEnabled(ECollisionEnabled::NoCollision); } void APMS_VFXTriggerActor::BeginPlay() { Super::BeginPlay(); DistanceToPlayer = DetectionSphere-&amp;gt;GetScaledSphereRadius(); if(GetWorld()-&amp;gt;GetNetMode() == NM_Standalone || GetWorld()-&amp;gt;GetNetMode() == NM_Client) { GetWorld()-&amp;gt;GetTimerManager().SetTimer(FCheckTimerHandle, this, &amp;amp;APMS_VFXTriggerActor::CheckDistance, 1.0f, true);&#x9;} } void APMS_VFXTriggerActor::CheckDistance() { APMS_ZombiePlayerCharacter* PlayerCharacter = Cast&amp;lt;APMS_ZombiePlayerCharacter&amp;gt;(GetWorld()-&amp;gt;GetFirstPlayerController()-&amp;gt;GetPawn()); if (PlayerCharacter) { float Distance = PlayerCharacter-&amp;gt;GetDistanceTo(this); if (Distance &amp;lt;= DistanceToPlayer &amp;amp;&amp;amp; !</description>
    </item>
    <item>
      <title>多人FPS游戏制作笔记</title>
      <link>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E4%BA%BAfps%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/</link>
      <pubDate>Fri, 23 May 2025 00:00:00 +0000</pubDate>
      <guid>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E4%BA%BAfps%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/</guid>
      <description>角色添加了四个骨骼，分别是第一人称视角的：LegMesh自己看自己的腿，FirstPersonMesh自己看自己的手，和其他玩家视角的全身模型：ThirdpersonMesh，以及ShadowMesh影子网格体&#xA;动画完成了人物的走跑（八方向混合空间）、跳（起跳—在空中—落地）、射击部分。&#xA;射击实现 protected: void SetupInputComponent() override; protected: UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = &amp;#34;EnhancedInput&amp;#34;, meta = (AllowPrivateAccess = &amp;#34;true&amp;#34;)) TObjectPtr&amp;lt;class UInputMappingContext&amp;gt; DefaultIMC; void ADemoPlayerController::SetupInputComponent() { Super::SetupInputComponent(); if(UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem&amp;lt;UEnhancedInputLocalPlayerSubsystem&amp;gt;(GetLocalPlayer())) { FModifyContextOptions Options; Options.bForceImmediately = true; Subsystem-&amp;gt;ClearAllMappings(); if(DefaultIMC) { Subsystem-&amp;gt;AddMappingContext(DefaultIMC, 0, Options); } } } 在SetupPlayerInputComponent中调用自定义输入组件绑定输入。&#xA;void ADemoPlayerCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); UDemoPlayerInputComponent* DemoInput = CastChecked&amp;lt;UDemoPlayerInputComponent&amp;gt;(PlayerInputComponent); if (DemoInput) { DemoInput-&amp;gt;SetupInputBindings(); } } void UDemoPlayerInputComponent::SetupInputBindings() { if(IA_DemoFire) { BindAction(IA_DemoFire, ETriggerEvent::Started, this, &amp;amp;UDemoPlayerInputComponent::StartFire); BindAction(IA_DemoFire, ETriggerEvent::Completed, this, &amp;amp;UDemoPlayerInputComponent::EndFire); } } 自定义输入组件中的开火函数用来调用ADemoPlayerCharacter的开火函数</description>
    </item>
    <item>
      <title>数据结构与UE模块创建</title>
      <link>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/tarrayandtmap/</link>
      <pubDate>Fri, 16 May 2025 00:00:00 +0000</pubDate>
      <guid>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/tarrayandtmap/</guid>
      <description>数据结构Array、List、Stack、Queue、TArray、TMap&#xA;UGit新增分支&#xA;UE模块创建&#xA;附件： List.cpp Queue.cpp Stack.cpp TArray.cpp TMap.cpp&#xA;Array.cpp&#xA;TArray TArray类型由两大属性定义：元素类型和可选分配器（默认FDefaultAllocator）。&#xA;TArray只是内存的包装器，是对一块动态分配的连续内存进行管理。&#xA;比如你要一次性从文件或网络中读取 100 个 FMyStruct，而不想一个一个 Add，还要调用构造函数再赋值，影响效率。就可以使用AddUninitialized。&#xA;TArray&amp;lt;FMyStruct&amp;gt; MyArray; MyArray.AddUninitialized(100); // 分配空间而不调用构造 // 假设你从磁盘中读了一块内存 FMemory::Memcpy(MyArray.GetData(), FileBuffer, 100 * sizeof(FMyStruct)); AddZeroed(int32 Count) 插入5个元素，但不会调用构造函数并且内存会被填充为0（memset）。适合纯数据结构体（POD）：结构体没有虚函数、继承、自定义构造和析构。比如FString就不是POD，因为管理堆内存、有构造和析构等。&#xA;SetNumUninitialized(int32 NewNum) 修改数组长度为100，扩容部分不会构造元素，只是扩展内存。&#xA;Slack Slack可调整数组的大小，为了避免每次添加元素都要重新分配内存，分配器提供的内存通常会超过必要内存，自认为和Vector一样。同样删除元素不会释放内存，此操作会是数组拥有Slack元素，也就是当前未使用的有效预分配元素储存槽。（可储存的元素数量 - 存储元素数量 = Slack）&#xA;堆 TArray拥有支持二叉堆数据结构的函数，调用Heapify函数可将现有数组转换为堆。&#xA;TArray&amp;lt;int32&amp;gt; HeapArr; for (int32 Val = 10; Val != 0; --Val) { HeapArr.Add(Val); } // HeapArr == [10,9,8,7,6,5,4,3,2,1] HeapArr.Heapify(); // HeapArr == [1,2,4,3,6,5,8,10,7,9] HeapPush 将新元素添加到堆，并重新排序维护堆。</description>
    </item>
  </channel>
</rss>
