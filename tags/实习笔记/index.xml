<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>实习笔记 on GeeTeng</title>
    <link>https://geeteng.github.io/tags/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 实习笔记 on GeeTeng</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 27 Jun 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://geeteng.github.io/tags/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>实习周报6.27</title>
      <link>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A56.27/</link>
      <pubDate>Fri, 27 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A56.27/</guid>
      <description>实习周报6.27 GAS部分知识点 ASC（Ability System Component）主要组件（谁放技能）&#xA;AS（Attribute Set）角色身上可以用float表示的属性，如生命值、体力值等（技能改变的属性）&#xA;GA（Gameplay Abilities）角色的技能，包括攻击、疾跑、施法、翻滚、使用道具等，但不包括基础移动和UI（技能逻辑）&#xA;GE（Gameplay Effects）用于修改属性，如增加移动速度等（技能的效果）&#xA;GC（Gameplay Cues）播放特效、音效等（技能的视效）&#xA;GameplayTag（技能涉及的条件）&#xA;GameplayTask（技能长时行动）&#xA;GameplayEvent（技能消息事件）&#xA;ASC 在构造函数中创建ASC组件，其中ReplicationMode三种模式：Full、Mixed、Minimal&#xA;比如大招GE会被同步给队友，但是普通技能的冷却时间不会被同步。但是AI设置为Minimal，因为不需要别人知道他的技能冷却时间等。&#xA;其中Mixed模式必须要设置拥有者为控制器&#xA;PMSAbilitySystemComponent = CreateDefaultSubobject&amp;lt;UPMS_AbilitySystemComponent&amp;gt;(CharacterASCName); PMSAbilitySystemComponent-&amp;gt;SetReplicationMode(EGameplayEffectReplicationMode::Mixed); PMSAttributeSetBase = CreateDefaultSubobject&amp;lt;UPMS_AttributeSetBase&amp;gt;(CharacterAttributeSetName); Attribute 有两个值，BaseValue和CurrentValue，其中CurrentValue是BaseValue加上GE给的临时修改值后得到的，比如BaseValue生命值100，捡到药水瓶CurrentValue = 150&#xA;在PreAttributeChange中处理对CurrentValue的修改以及取值范围问题, 在PostGameplayEffectExecute中处理GE对BaseValue的修改&#xA;Meta Attribute是临时的、可被任意GE修改、不可同步的，将于任意Attribute交互的临时属性。 比如伤害值作为Meta Attribute占位符, 而不是使用GE直接修改生命值Attribute, 使用这种方法, 伤害值就可以在GameplayEffectExecutionCalculation中由buff和debuff修改, 并且可以在AttributeSet中进一步操作。&#xA;Set和Init的区别是在于Set只能设置basevalue， 而init可以设置currentvalue和basevalue&#xA;在PlayerCharacterBase的BeginPlay中，绑定委托、初始化属性、初始化GA&#xA;void APMS_CharacterBase::BeginPlay() { Super::BeginPlay(); BindAttributesDelegate(); PMSAttributeSetBase-&amp;gt;InitAttributes(); FTimerHandle hld; GetWorld()-&amp;gt;GetTimerManager().SetTimer(hld, this, &amp;amp;APMS_CharacterBase::InitAttributes, 0.1f); } void APMS_CharacterBase::BindAttributesDelegate() { if (IsValid(PMSAbilitySystemComponent) &amp;amp;&amp;amp; IsValid(PMSAttributeSetBase)) { HealthChangedDelegateHandle = PMSAbilitySystemComponent-&amp;gt;GetGameplayAttributeValueChangeDelegate(PMSAttributeSetBase-&amp;gt;GetHealthAttribute()).AddUObject(this, &amp;amp;ThisClass::HealthChanged); // .</description>
    </item>
    <item>
      <title>实习周报6.18</title>
      <link>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A56.18/</link>
      <pubDate>Wed, 18 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A56.18/</guid>
      <description>实习周报6.18 场景飞屑特效表现功能 当角色进入到一个触发范围内会在角色位置上生成特效&#xA;使用两个定时器分别是FPlayVfxTimerHandle和FCheckTimerHandle&#xA;删除Tick函数设置bCanEverTick = false 因为不使用到Tick所以删除会提升性能&#xA;构造函数中初始化初始化一个可见的无碰撞球体，为了布置场景时看到范围。在BeginPlay中直接获取球体半径作为DistanceToPlayer的值。&#xA;FCheckTimerHandle定时器用于每秒判断角色是否进入到范围内&#xA;FPlayVfxTimerHandle定时器用于不断播放特效，并设置一个bIsVFXPlaying用于判断是否正在播放特效，如果已经在播放特效了并且超出距离就会清空FPlayVfxTimerHandle特效播放定时器；如果没有在播放特效并且在距离范围内则会开启定时器。&#xA;为什么一定需要bIsVFXPlaying，因为否则人物在距离内时第一个FCheckTimerHandle会不断地调用CheckDistance函数导致无法播放特效。&#xA;APMS_VFXTriggerActor::APMS_VFXTriggerActor() { // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don&amp;#39;t need it. PrimaryActorTick.bCanEverTick = false; DetectionSphere = CreateDefaultSubobject&amp;lt;USphereComponent&amp;gt;(TEXT(&amp;#34;DetectionSphere&amp;#34;)); RootComponent = DetectionSphere; DetectionSphere-&amp;gt;SetCollisionEnabled(ECollisionEnabled::NoCollision); } void APMS_VFXTriggerActor::BeginPlay() { Super::BeginPlay(); DistanceToPlayer = DetectionSphere-&amp;gt;GetScaledSphereRadius(); if(GetWorld()-&amp;gt;GetNetMode() == NM_Standalone || GetWorld()-&amp;gt;GetNetMode() == NM_Client) { GetWorld()-&amp;gt;GetTimerManager().SetTimer(FCheckTimerHandle, this, &amp;amp;APMS_VFXTriggerActor::CheckDistance, 1.0f, true);&#x9;} } void APMS_VFXTriggerActor::CheckDistance() { APMS_ZombiePlayerCharacter* PlayerCharacter = Cast&amp;lt;APMS_ZombiePlayerCharacter&amp;gt;(GetWorld()-&amp;gt;GetFirstPlayerController()-&amp;gt;GetPawn()); if (PlayerCharacter) { float Distance = PlayerCharacter-&amp;gt;GetDistanceTo(this); if (Distance &amp;lt;= DistanceToPlayer &amp;amp;&amp;amp; !</description>
    </item>
    <item>
      <title>实习周报6.6</title>
      <link>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A56.6/</link>
      <pubDate>Fri, 06 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A56.6/</guid>
      <description>实习周报6.6 武器组件化&#xA;将武器的功能抽象成一个个独立可复用的模块，然后组合到武器实例上。比如射线枪和后坐力还有换弹都可以抽象成一个个功能，然后自由组合。&#xA;组件继承UActorComponent，我写了两个组件分别是子弹管理组件和开火组件。&#xA;子弹管理组件 子弹管理组件定义了子弹数量和初始化子弹数量、判断子弹数量是否满足开火条件、子弹减少等方法。并将之前在武器类中子弹数量变化的代理和子弹数量的网络同步转移到当前子弹管理组件脚本中。&#xA;void UAmmoManagerComponent::GetLifetimeReplicatedProps(TArray&amp;lt;FLifetimeProperty&amp;gt;&amp;amp; OutLifetimeProps) const { Super::GetLifetimeReplicatedProps(OutLifetimeProps); DOREPLIFETIME(UAmmoManagerComponent, AmmoCount); } UAmmoManagerComponent::UAmmoManagerComponent() { PrimaryComponentTick.bCanEverTick = true; SetIsReplicatedByDefault(true); } void UAmmoManagerComponent::BeginPlay() { Super::BeginPlay(); AmmoCount = MaxAmmo; } void UAmmoManagerComponent::InitializeAmmo(int32 InAmmoCount, int32 InMaxAmmo) { MaxAmmo = InMaxAmmo; AmmoCount = InAmmoCount; } void UAmmoManagerComponent::ExpendAmmoCount() { -- AmmoCount; } bool UAmmoManagerComponent::EnoughAmmoToFire() { return AmmoCount &amp;gt; 0; } void UAmmoManagerComponent::SetMaxAmmo(int32 NewMaxAmmo) { MaxAmmo = NewMaxAmmo; AmmoCount = FMath::Clamp(AmmoCount, 0, MaxAmmo); OnRep_AmmoCount(); } void UAmmoManagerComponent::OnRep_AmmoCount() { OnAmmoChanged.</description>
    </item>
    <item>
      <title>实习周报5.30</title>
      <link>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A55.30/</link>
      <pubDate>Fri, 30 May 2025 00:00:00 +0000</pubDate>
      <guid>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A55.30/</guid>
      <description>实习周报5.30 委托_生命值和子弹数量更新 委托：是一种观察者模式，也被称为代理，主要用于监听事件或变量的变化。监听者将需要响应的函数绑定到委托对象上，使得委托在触发时调用所绑定的函数。&#xA;在UE中，按照委托函数个数分为单播、多播，按照是否可暴露给蓝图分为静态和动态。所以一共四种类型。&#xA;射击子弹数量同步到UI上使用动态多播委托&#xA;动态多播委托在执行时需要实时在类中按照给定的函数名字查找对应的函数，因此执行速度慢，维护了一个由动态单播委托组成的TArray数组，依托动态单播委托实现。&#xA;只有动态多播可以被蓝图绑定，需要加标记BlueprintAssignable。&#xA;在武器类中声一个带有两个参数的动态多播委托，传递当前子弹数量和最大子弹数量。&#xA;FOnAmmoChanged是一个委托类型，可以将多个处理函数绑定到委托上。&#xA;/** 子弹变化 **/ DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnAmmoChanged, int32, AmmoCount, int32, MaxAmmo); UPROPERTY(BlueprintAssignable, Category = &amp;#34;Events&amp;#34;) FOnAmmoChanged OnAmmoChanged; // 创建委托实例 /** 生命值变化 **/ DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnHealthChanged, int32, Health); UPROPERTY(BlueprintAssignable, Category = &amp;#34;Events&amp;#34;) FOnHealthChanged OnHealthChanged; 在武器类的射击函数中添加OnAmmoChanged.Broadcast(AmmoCount, MaxAmmo); // 用来广播委托&#xA;在角色类的TakeDamage受伤函数中添加OnHealthChanged.Broadcast(Health);&#xA;在玩家控制器类BeginPlay中绘制UserWidget。&#xA;void ADemoPlayerController::BeginPlay() { Super::BeginPlay(); if (IsLocalController()) { if(GameplayUserWidgetClass) { GameplayUserWidget = CreateWidget&amp;lt;UDemoGameplayUserWidget&amp;gt;(this, GameplayUserWidgetClass); if(GameplayUserWidget) { GameplayUserWidget-&amp;gt;AddToViewport(); } } } } 在角色控制器类中实现可以调用UserWidget类更新UI的函数，还有一进游戏的初始化UI函数&#xA;void ADemoPlayerController::OnAmmoChanged(int32 AmmoCount, int32 MaxAmmo) { if(GameplayUserWidget) { GameplayUserWidget-&amp;gt;UpdateAmmoDisplay(AmmoCount, MaxAmmo); } } void ADemoPlayerController::OnHealthChanged(int32 Health) { if (GameplayUserWidget) { GameplayUserWidget-&amp;gt;UpdateHealthDisplay(Health); } } void ADemoPlayerController::InitGameplayUserWidget() { ADemoPlayerCharacter* PlayerCharacter = Cast&amp;lt;ADemoPlayerCharacter&amp;gt;(GetPawn()); GameplayUserWidget-&amp;gt;UpdateAmmoDisplay(PlayerCharacter-&amp;gt;CurrentWeapon-&amp;gt;AmmoCount, PlayerCharacter-&amp;gt;CurrentWeapon-&amp;gt;MaxAmmo); GameplayUserWidget-&amp;gt;UpdateHealthDisplay(PlayerCharacter-&amp;gt;Health); } UserWidget中更新子弹数量函数</description>
    </item>
    <item>
      <title>实习周报5.23</title>
      <link>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A55.23/</link>
      <pubDate>Fri, 23 May 2025 00:00:00 +0000</pubDate>
      <guid>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A55.23/</guid>
      <description>实习周报5.23 以下部分只是最初实现的代码，后来更改了武器组件化还有网络同步&#xA;出现的问题： ​ 1. 已解决 角色混合空间移动缺少左右动画，导致左右腿移动时重叠。—— 骨骼没适配&#xA;​ 2. 已解决 多人游戏中玩家奔跑只能自己看到 没办法被其他玩家看到 —— MaxWalkSpeed需要网络同步&#xA;实现了人物的移动、奔跑、跳跃、射击。&#xA;角色添加了四个骨骼，分别是第一人称视角的：LegMesh自己看自己的腿，FirstPersonMesh自己看自己的手，和其他玩家视角的全身模型：ThirdpersonMesh，以及ShadowMesh影子网格体&#xA;动画完成了人物的走跑（八方向混合空间）、跳（起跳—在空中—落地）、射击部分。&#xA;射击实现 protected: void SetupInputComponent() override; protected: UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = &amp;#34;EnhancedInput&amp;#34;, meta = (AllowPrivateAccess = &amp;#34;true&amp;#34;)) TObjectPtr&amp;lt;class UInputMappingContext&amp;gt; DefaultIMC; void ADemoPlayerController::SetupInputComponent() { Super::SetupInputComponent(); if(UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem&amp;lt;UEnhancedInputLocalPlayerSubsystem&amp;gt;(GetLocalPlayer())) { FModifyContextOptions Options; Options.bForceImmediately = true; Subsystem-&amp;gt;ClearAllMappings(); if(DefaultIMC) { Subsystem-&amp;gt;AddMappingContext(DefaultIMC, 0, Options); } } } 在SetupPlayerInputComponent中调用自定义输入组件绑定输入。&#xA;void ADemoPlayerCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); UDemoPlayerInputComponent* DemoInput = CastChecked&amp;lt;UDemoPlayerInputComponent&amp;gt;(PlayerInputComponent); if (DemoInput) { DemoInput-&amp;gt;SetupInputBindings(); } } void UDemoPlayerInputComponent::SetupInputBindings() { if(IA_DemoFire) { BindAction(IA_DemoFire, ETriggerEvent::Started, this, &amp;amp;UDemoPlayerInputComponent::StartFire); BindAction(IA_DemoFire, ETriggerEvent::Completed, this, &amp;amp;UDemoPlayerInputComponent::EndFire); } } 自定义输入组件中的开火函数用来调用ADemoPlayerCharacter的开火函数</description>
    </item>
    <item>
      <title>实习周报5.16</title>
      <link>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A55.16/</link>
      <pubDate>Fri, 16 May 2025 00:00:00 +0000</pubDate>
      <guid>https://geeteng.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A55.16/</guid>
      <description>实习周报5.16 数据结构Array、List、Stack、Queue、TArray、TMap&#xA;UGit新增分支&#xA;UE模块创建&#xA;附件： List.cppQueue.cppTMap.cppStack.cppTArray.cppArray.cpp&#xA;TArray TArray类型由两大属性定义：元素类型和可选分配器（默认FDefaultAllocator）。&#xA;TArray只是内存的包装器，是对一块动态分配的连续内存进行管理。&#xA;比如你要一次性从文件或网络中读取 100 个 FMyStruct，而不想一个一个 Add，还要调用构造函数再赋值，影响效率。就可以使用AddUninitialized。&#xA;TArray&amp;lt;FMyStruct&amp;gt; MyArray; MyArray.AddUninitialized(100); // 分配空间而不调用构造 // 假设你从磁盘中读了一块内存 FMemory::Memcpy(MyArray.GetData(), FileBuffer, 100 * sizeof(FMyStruct)); AddZeroed(int32 Count) 插入5个元素，但不会调用构造函数并且内存会被填充为0（memset）。适合纯数据结构体（POD）：结构体没有虚函数、继承、自定义构造和析构。比如FString就不是POD，因为管理堆内存、有构造和析构等。&#xA;SetNumUninitialized(int32 NewNum) 修改数组长度为100，扩容部分不会构造元素，只是扩展内存。&#xA;Slack Slack可调整数组的大小，为了避免每次添加元素都要重新分配内存，分配器提供的内存通常会超过必要内存，自认为和Vector一样。同样删除元素不会释放内存，此操作会是数组拥有Slack元素，也就是当前未使用的有效预分配元素储存槽。（可储存的元素数量 - 存储元素数量 = Slack）&#xA;堆 TArray拥有支持二叉堆数据结构的函数，调用Heapify函数可将现有数组转换为堆。&#xA;TArray&amp;lt;int32&amp;gt; HeapArr; for (int32 Val = 10; Val != 0; --Val) { HeapArr.Add(Val); } // HeapArr == [10,9,8,7,6,5,4,3,2,1] HeapArr.Heapify(); // HeapArr == [1,2,4,3,6,5,8,10,7,9] HeapPush 将新元素添加到堆，并重新排序维护堆。&#xA;HeapPop和HeapPopDiscard函数用于移除堆的顶部节点，前者会返回顶部元素副本，而后者仅移除节点。&#xA;HeapRemoveAt将删除数组中给定索引的元素，并重新排列元素维护堆。&#xA;可使用 HeapTop 检查堆的顶部节点。</description>
    </item>
  </channel>
</rss>
