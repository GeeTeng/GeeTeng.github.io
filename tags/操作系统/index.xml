<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>操作系统 on GeeTeng</title>
    <link>https://geeteng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
    <description>Recent content in 操作系统 on GeeTeng</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 19 Mar 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://geeteng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>内存管理</title>
      <link>https://geeteng.github.io/posts/cs_basic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Wed, 19 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://geeteng.github.io/posts/cs_basic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>内存回收OOM malloc分配的是虚拟内存，而非物理内存。当这块虚拟内存被读写了的时候，CPU会访问这块虚拟内存，然后发现该虚拟内存没有被映射到物理内存，CPU就会产生缺页中断，进程从用户态 一&amp;gt; 内核态。&#xA;缺页中断处理函数（Page Fault Handler）会判断是否有空闲的物理内存，如果有，就直接分配物理内存，否则回收内存。&#xA;有两种回收内存的方式：后台内存回收（异步）、直接内存回收（如果后台回收跟不上进程内存申请的速度就会开始直接回收，这个过程是同步的，会阻塞进程执行）。&#xA;如果直接内存回收，仍旧不满足申请的内存大小，那么就会触发OOM（Out Of Memory）机制。&#xA;OOM机制会根据算法杀死一个占用物理内存最高的进程，如果还是无法满足，继续杀死进程，直到释放足够多的内存。&#xA;如何保护一个进程不被OOM杀掉呢？&#xA;Linux中通过oom_badness()对每个进程打分，得分最高的进程会被杀掉。得分机制：&#xA;进程所占用物理内存页面数量 每个进程的OOM校准值oom_score_adj [-1000, 1000] 我们可以通过调整校准值来防止进程被OOM杀掉。比如说设置成-1000，无论如何都不会被杀掉。但是不建议将业务程序这样设置，因为如果某个业务程序发生内存泄漏，而又无法被杀掉，那么OOM会把其他进程都杀掉了。&#xA;文件页和匿名页 哪些内存会被回收？&#xA;文件页：内核缓存的文件数据（Cache）和内核缓存的磁盘数据（Buffer）都属于文件页。如果被应用程序修改过并且还没写入磁盘的数据叫做脏页。回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存。&#xA;匿名页：没有磁盘这样的实际载体，比如栈和堆。这些内存不能直接释放，因为很可能会再次被访问。将不常访问的数据换出物理内存放到磁盘中的swap分区，如果需要访问，就从磁盘中读入内存（会发生缺页中断）而常访问的数据会在物理内存RAM / Cache / TLB——系统会根据数据的访问热度，在多个层次自动做缓存或常驻处理。&#xA;文件页是比如说我d盘里有一个文件然后程序去读取，读取之后可以丢掉因为磁盘里有这个东西，但是匿名页是没有实际载体，是在程序运行中分配的数据。&#xA;文件页和匿名页的回收都基于LRU算法。&#xA;回收内存除了回收干净页，都会发生磁盘 I/O的，这会影响系统性能。&#xA;可以申请虚拟内存超过物理内存吗？&#xA;在32位操作系统，进程最大只能申请3GB的虚拟内存。&#xA;在64位操作系统，进程最大可以申请128TB的虚拟内存。&#xA;所以如果想在4GB的物理内存空间上直接申请8GB的虚拟内存，在32位操作系统上会申请失败，而在64位会成功。&#xA;如果有Swap分区，即使物理内存只有4GB，进程也可以正常使用8GB的内存。&#xA;LRU预读失效 LRU预读失效怎么办？&#xA;如果应用程序想读取 0 - 3KB 范围内的数据，由于磁盘基本读写单位为 block（4KB），于是操作系统至少会读 0 - 4KB 的内容，但是由于空间局部性原理（靠近当前被访问数据的数据，在未来很大概率会被访问到），所以会把[4, 8]，[8, 12]以及[12, 16]都加载到内存。&#xA;预读机制带来的好处是减少磁盘 I/O 次数，提高系统磁盘 I/O 吞吐量。&#xA;预读失效：就是这些被提前加载进来的页面没有被访问，相当于预读白做了。不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是热点数据，这样就大大降低了缓存命中率。&#xA;想要避免预读失效，就要尽可能地保证预读的数据停留内存的时间要短，真正的热点数据尽可能久的留在内存。Linux操作系统就实现了两个LRU链表：活跃LRU链表(active_list)和非活跃LRU链表(inactive_list)。&#xA;预读页就只需要加入到 inactive list 区域的头部，当页被真正访问的时候，才将页插入 active list 的头部。&#xA;缓存污染 缓存污染怎么办？&#xA;虽然两个LRU链表可以解决预读失效的问题，但是还会存在缓存污染的问题。当批量读取数据时，如果数据被访问了一次就加入到LRU中，那么活跃链表中会一下子淘汰了很多热点数据，而那些被新加入的数据很长一段时间不会被访问，导致了整个LRU活跃链表被污染。等到下一次读到那些热点数据的时候，一下子发生了很多次磁盘I/O，性能急剧下降。</description>
    </item>
    <item>
      <title>操作系统</title>
      <link>https://geeteng.github.io/posts/cs_basic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 10 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://geeteng.github.io/posts/cs_basic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>1. 第一章 操作系统概述 1.1 操作系统概念、特征 操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境集合。&#xA;并发 并发是指两个或多个事件在同一时间间隔内发生。操作系统的并发是通过分时得以实现的。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它具有处理和调度多个程序同时执行的能力。&#xA;共享 资源共享就是共享，系统中的资源可供内存中多个并发执行的进程同时使用，可分为以下两种。&#xA;互斥共享方式&#xA;比如打印机，不能同时打印两份内容，不然会造成内容混淆。&#xA;同时访问方式&#xA;交替的对该资源进行访问 “分时共享”。&#xA;虚拟 操作系统中利用了多种虚拟技术，分别用来实现虚拟处理机、虚拟内存和虚拟外部设备。&#xA;在虚拟处理器技术中，让多道程序并发执行来分时使用一台处理器，虽然只有一台处理器，但是能同时为多个用户服务。把一台物理上的CPU虚拟为多态逻辑上的CPU称为虚拟处理器。&#xA;虚拟存储器，从逻辑上来扩充存储器的容量。&#xA;虚拟设备技术，将一台物理IO设备虚拟为多台逻辑上的IO设备，允许多个用户同时访问的共享设备。&#xA;异步 在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。&#xA;操作系统的目标和功能 为了给多道程序提供良好的运行环境，操作系统应该具有：处理器管理、存储器管理、文件管理和设备管理，还必须向用户提供接口，同时操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。&#xA;处理器管理&#xA;对处理器的管理可归结为对进程的管理，主要功能有：进程控制、进程同步、进程通信、死锁处理、处理器调度等。&#xA;存储器管理&#xA;方便用户使用以及提高内存的利用率，存储器管理应具备：内存分配、地址映射、内存保护、共享和内存扩充等。&#xA;文件管理&#xA;包括文件的存储空间管理、目录管理和文件读写管理、文件保护。&#xA;设备管理&#xA;完成用户的IO请求，主要包括混充管理、设备分配、设备处理和虚拟设备等。&#xA;为了方便用户使用操作系统，操作系统还提供了用户接口，分为以下两类。&#xA;命令接口&#xA;使用命令接口进行作业控制的主要方式有两种：联机命令接口和脱机命令接口。&#xA;程序接口&#xA;程序接口由一组系统调用命令组成，用户可以直接使用命令向系统提出各种请求。&#xA;操作系统的结构 简单结构、模块化结构、分层式结构、微内核结构。&#xA;1.3 操作系统的运行环境 操作系统在具体实现上划分了用户态、核心态。&#xA;操作系统内核包括以下4方面：&#xA;时钟管理&#xA;操作系统需要通过时钟管理，向用户提供标准的系统时间。通过时钟中断的管理，可以实现进程切换。&#xA;中断机制&#xA;引入中断机制是为了提高多道程序运行环境中CPU的利用率。&#xA;原语&#xA;原语处于操作系统最底层，是最接近硬件的部分；具有原子性（一气呵成，不可中断）；运行时间短、调用频繁。&#xA;系统控制的数据结构及处理&#xA;常见的基本操作有以下3种，进程管理、存储器管理、设备管理。&#xA;中断和异常 引入核心态和用户态之后，就需要考虑如何在这两种状态下切换。**中断是让操作系统内核夺回CPU使用权的唯一途径。**内核工作在核心态，应用程序工作在用户态，系统不允许用户使用核心态的功能，但是它们又必须使用。&#xA;中断（外中断）&#xA;中断信号来源于CPU外部，与当前执行的指令无关。比如说时钟中断和I/O中断请求，当输入输出任务完成时，向CPU发送中断信号，或时钟部件每隔50ms发送一个中断信号。&#xA;异常（内中断）&#xA;源于CPU执行指令内部，比如程序的非法操作。&#xA;一些由用户态转为核心态的例子：1）用户程序要求系统服务 2）发生一次中断 3）用户程序产生错误 4）用户程序企图执行特权指令&#xA;2. 第二章 进程管理 2.1 进程与线程 进程控制块（PCB）描述进程的基本情况和运行状态，PCB是进程存在的唯一标志。&#xA;进程由PCB、程序段、数据段组成。&#xA;进程的特征 动态性(最基本的特性)、并发性、独立性、异步性、结构性。</description>
    </item>
  </channel>
</rss>
